.. _chap:grampcStructure:

Usage of GRAMPC
===============

This chapter describes how to use GRAMPC in C and via the interface to
Matlab/Simulink. Note that the implementation of the problem
formulation is described in :ref:`sec:ProblemImplementation`
and therefore not repeated here.

Using GRAMPC in C
-----------------

A high level of portability is provided by GRAMPC in view of different
operating systems and hardware devices. The main components are written
in plain C without the use of external libraries, also see the
discussion in :ref:`sec:Structure`. This section describes
the usage of GRAMPC in C including initialization, compilation and
running the MPC framework.

.. _sec:MainComponents:

Main components of GRAMPC
~~~~~~~~~~~~~~~~~~~~~~~~~

As illustrated in Figure :numref:`fig:grampcMainComponents`, GRAMPC
contains initializing as well as running files, different integrators
for the system and adjoint dynamics (:ref:`chap:ProblemFormulation` and :ref:`chap:AlgOpt`) and
functions to alter the options and parameters (also see :ref:`chap:ProblemFormulation` and :ref:`chap:AlgOpt`).

In more detail, GRAMPC comprises the following main files (see also
Appendix :ref:`appendix:FunctionInterface` for the function
interface):

- ``grampc_init.c``: Functions for initializing GRAMPC.

- ``grampc_alloc.c``: Functions for memory allocation and deallocation.

- ``grampc_run.c``: Functions for running GRAMPC including the implemented augmented Lagrangian algorithm and the underlying gradient algorithm. Further functions of this file are concerned with the line search strategies and the update steps of the primal and dual variables as described in :ref:`chap:AlgOpt`.

- ``grampc_setparam.c``: Provides several functions for setting problem-related parameters, see the description in :ref:`chap:ProblemFormulation` and the list of parameters in Table :numref:`tab:ListOfParameters`.

- ``grampc_setopt.c``: Provides several functions for setting algorithmic options, see the description in :ref:`chap:AlgOpt` and the list of options in Table :numref:`tab:ListOfOptions`.

- ``grampc_mess.c``: Function for printing information regarding the initialization as well as execution of GRAMPC (e.g. errors, convergence behavior of the augmented Lagrangian algorithm or status of integrators).

- ``grampc_util.c``: Auxiliary functions for the GRAMPC toolbox such as memory management and trajectory interpolation. It also contains the function ``grampc_estim_penmin`` to compute an estimate of the minimal penalty parameter, cf. :ref:`sec:AlgOpt:EstimPenMin`.

- ``simpson.c``: Function for integrating the integral cost by means of the Simpson rule.

- ``trapezoidal.c``: Function for integrating the integral cost by means of the trapezoidal rule.

- ``euler1.c``: Euler forward integration scheme with fixed step size.

- ``eulermod2.c``: Modified Euler integration scheme with fixed step size.

- ``heun2.c``: Heun integration scheme with fixed step size.

- ``rodas.c``: Semi-implicit Rosenbrock integration scheme with variable step size. The code follows from an f2c conversion of the original Fortran files of RODAS :footcite:`Rodas:Webpage:2018` and are directly included in the GRAMPC source files.

- ``ruku45.c``: Runge-Kutta integration scheme of order 4 with variable step size.

- ``discrete.c``: Discrete integrator.

.. figure:: img/MainComponents.*
    :name: fig:grampcMainComponents

    Main components of GRAMPC

.. _`chap:grampcStructure:initialization`:

Initialization of GRAMPC
~~~~~~~~~~~~~~~~~~~~~~~~

The global initialization of GRAMPC is done via the routine

::

   void grampc_init(typeGRAMPC **grampc, typeUSERPARAM *userparam)

where the overall structure variable contains the following
substructures (see :ref:`appendix:DataTypes` for the
definition of the data type):

-  ``sol`` (data type ``typeGRAMPCsol``): Contains the optimization variables
   :math:`(\mb{u}^{i+1},\mb{p}^{i+1},T^{i+1})` and the
   interpolated state :math:`\mb{x}^{i+1}` in the next MPC step
   as well as the corresponding cost values
   :math:`\bar J(\mb{u}^{i+1}, \mb{p}^{i+1}, T^{i+1}, \mb{\mu}^{i+1},
   \mb{c}^{i+1};\mb{x}_0)` and
   :math:`J(\mb{u}^{i+1}, \mb{p}^{i+1}, T^{i+1};\mb{x}_0)`,
   respectively. The control :math:`\mb{u}^{i+1}` and the state
   :math:`\mb{x}^{i+1}` refer to the corresponding trajectories
   evaluated at the sampling time :math:`\Delta t`. In addition, the
   substructure ``sol`` contains the evaluated functions of the defined
   state constraints, some status information, and an array in which the
   number of gradient iterations are stored in each augmented Lagrangian
   step.

-  ``param`` (data type ``typeGRAMPCparam``): Contains the parameter structure of GRAMPC. 
   A detailed description of all parameters is given in :ref:`chap:ProblemFormulation`.

-  ``opt`` (data type ``typeGRAMPCopt``): Contains the option structure of GRAMPC. 
   A detailed description of all options is given in :ref:`chap:AlgOpt`.

-  ``rws`` (data type ``typeGRAMPCrws``): Contains the real-time workspace of GRAMPC including calculations of the augmented Lagrangian algorithm and the gradient algorithm along the prediction horizon.

-  ``userparam`` (data type ``typeUSERPARAM``): Can be used to define parameters, e.g. to parametrize the cost functional, the system dynamics or the state constraints.

The definition of these data types is given in Appendix :ref:`appendix:DataTypes`. 
The deallocation of is done by means of the function

.. code-block:: c

   void grampc_free(typeGRAMPC **grampc)

.. _sec:setting_opt_par:

Setting options and parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The single options in Table :ref:`tab:ListOfOptions` are set via the functions

.. code-block:: c

   void grampc_setopt_real(const typeGRAMPC *grampc, const typeChar *optName, ctypeRNum optValue)
   void grampc_setopt_real_vector(const typeGRAMPC *grampc, const typeChar *optName, ctypeRNum *optValue)
                           
   void grampc_setopt_int(const typeGRAMPC *grampc, const typeChar *optName, ctypeInt optValue)
   void grampc_setopt_int_vector(const typeGRAMPC *grampc, const typeChar *optName, ctypeInt *optValue)
                          
   void grampc_setopt_string(const typeGRAMPC *grampc, const typeChar *optName, const typeChar *optValue)

for option values with floating point, integer and string type, respectively. 
An overview of the current options can be displayed by using

.. code-block:: c

   void grampc_printopt(typeGRAMPC *grampc)

| **Example** **(Setting options in C)**

The number of gradient iterations, the integration scheme, and the relative tolerance of the integrator can be set in the following way:

.. code-block:: c

   ...
   /********* declaration *********/
   typeGRAMPC *grampc; 
   ...

   /********* option definition *********/
   /* Basic algorithmic options */
   ctypeInt MaxGradIter = 2;

   /* System integration */
   const char* Integrator = "ruku45";
   ctypeRNum IntegratorRelTol = 1e-3;
   ...
   	
   /********* grampc init *********/
   grampc_init(&grampc, userparam);
   ...

   /********* setting options *********/
   grampc_setopt_int(grampc, "MaxGradIter", MaxGradIter);

   grampc_setopt_string(grampc, "Integrator", Integrator);
   grampc_setopt_real(grampc, "IntegratorRelTol", IntegratorRelTol);
   ...

Similar to setting the GRAMPC options, the parameters in Table :ref:`tab:ListOfParameters` are set according to their data type with the following functions:

.. code-block:: c

   void grampc_setparam_real(const typeGRAMPC *grampc, const typeChar *paramName, ctypeRNum paramValue);
                             
   void grampc_setparam_real_vector(const typeGRAMPC *grampc, const typeChar *paramName, ctypeRNum *paramValue);

An overview of the parameters can be displayed by using

.. code-block:: c

   void grampc_printparam(const typeGRAMPC *grampc);

| **Example** **(Setting parameters in C)**

The sampling time, the prediction horizon, and the initial conditions for a system with two states and one control input can be set in the following way:

.. code-block:: c

   ...
   /********* parameter definition *********/
   ctypeRNum dt = (typeRNum)0.001;
   ctypeRNum Thor = 6.0;

   ctypeRNum x0[NX] = {-1,-1};
   ctypeRNum u0[NU] = {0};


   /********* setting parameters *********/
   grampc_setparam_real(grampc, "dt", dt);
   grampc_setparam_real(grampc, "Thor", Thor);
   grampc_setparam_real_vector(grampc, "x0", x0);
   grampc_setparam_real_vector(grampc, "u0", u0);
   ...

.. _sec:CompileRun:

Compiling and calling GRAMPC
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

GRAMPC can be integrated into an executable program after the problem formulation (cf. :ref:`chap:ProblemFormulation`) as well as options and parameters are provided. 
A makefile for compilation purposes is provided in the folder ``<grampc_root>/examples/TEMPLATES``. The main calling routine for GRAMPC is

.. code-block:: c

   void grampc_run(const typeGRAMPC *grampc)

The following code demonstrates how to integrate GRAMPC within an MPC loop by completing the ball-on-plate example, cf. :ref:`sec:ball-on-plate`. 
The code is part of the file ``main_BALL_ON_PLATE.c`` contained in the GRAMPC folder ``<grampc_root>/examples/BallOnPLate``.

| **Example** **(C code for running GRAMPC within an MPC loop)**

.. code-block:: c

   #include "grampc.h"   /* contains all necessary header files */

   #define NX	2
   #define NU	1
   #define NC  4
   #define NP  0

   int main()
   {
     /********* Declaration and parameter definition *********/
     typeGRAMPC *grampc;
     typeInt iMPC, MaxSimIter, i;
     ctypeRNum Tsim = 8.0;
     clock_t tic, toc;
     typeRNum *CPUtimeVec;
     typeRNum CPUtime = 0;
       
     ctypeRNum x0[NX] = {0.1,0.01};   ctypeRNum xdes[NX] = {-0.2,0.0}; 
     ctypeRNum u0[NU] = {0.0};        ctypeRNum udes[NU] = {0.0};  
     ctypeRNum umax[NU] = {0.0524};   ctypeRNum umin[NU] = {-0.0524};
     
     ctypeRNum Thor = 0.3;
     ctypeRNum dt = (typeRNum)0.01;
     typeRNum t = (typeRNum)0.0;
     
     /********* userparam *********/
     typeRNum param[9] = { 100, 10, 1, 100, 10, -0.2, 0.01, -0.1, 0.1 };
     typeUSERPARAM *userparam = param; 
     
     /********* grampc init *********/
     grampc_init(&grampc, userparam);
     
     /********* Option definition *********/
     /* Basic algorithmic options */
     ctypeRNum Nhor = 10;
     ctypeInt MaxGradIter = 2;
     ctypeInt MaxMultIter = 3;
     
     ctypeRNum AugLagUpdateGradientRelTol = (typeRNum)1e0;
     ctypeRNum ConstraintsAbsTol[4] = {1e-3, 1e-3, 1e-3, 1e-3};
     
     /********* set parameters and option *********/
     grampc_setparam_real_vector(grampc, "x0", x0);
     grampc_setparam_real_vector(grampc, "xdes", xdes);

     grampc_setparam_real_vector(grampc, "u0", u0);
     grampc_setparam_real_vector(grampc, "udes", udes);
     grampc_setparam_real_vector(grampc, "umax", umax);
     grampc_setparam_real_vector(grampc, "umin", umin);
   	
     grampc_setparam_real(grampc, "Thor", Thor);
     grampc_setparam_real(grampc, "dt", dt);
     grampc_setparam_real(grampc, "t0", t);

     /********* Option definition *********/
     grampc_setopt_int(grampc, "Nhor", Nhor);
     grampc_setopt_int(grampc, "MaxGradIter", MaxGradIter);
     grampc_setopt_int(grampc, "MaxMultIter", MaxMultIter);
     
     grampc_setopt_real(grampc,"AugLagUpdateGradientRelTol",AugLagUpdateGradientRelTol);
     grampc_setopt_real_vector(grampc,"ConstraintsAbsTol",ConstraintsAbsTol);

     /********* estimate and set PenaltyMin *********/
     grampc_estim_penmin(grampc, 1);
     
     /* MPC loop */
     for (iMPC = 0; iMPC <= MaxSimIter; iMPC++) {
         tic = clock();
   	  grampc_run(grampc);
   	  toc = clock();
   	  CPUtimeVec[iMPC] = (typeRNum)((toc - tic) * 1000 / CLOCKS_PER_SEC);
   	  
   	  /* check solver status */
   	  if (grampc->sol->status > 0) {
   		  if (grampc_printstatus(grampc->sol->status, STATUS_LEVEL_ERROR)) {
   			  myPrint("at iteration %i:\n -----\n", iMPC);
   		  }
   	  }
   	  
   	  /* update state and time */
   	  t = t + dt;
   	  grampc_setparam_real_vector(grampc, "x0", grampc->sol->xnext);
     }
     
     /* Memory deallocation */
     grampc_free(&grampc);
     free(CPUtimeVec);
     
     return 0;
   }

The structure ``grampc`` is initialized at the beginning and some options are set.
Afterwards, the mandatory as well as some optional parameters are defined in the code. 
GRAMPC is then repetitively executed until a defined simulation time is reached. 
Note that the estimate of the minimal penalty value :math:`c_\text{min}` is determined via the function ``grampc_estim_penmin`` before the augmented Lagrangian algorithm is executed, also see the discussion in :ref:`sec:AlgOpt:EstimPenMin`.

For a more convenience MPC design, there are several status flags that can be printed after each MPC step. 
As shown in the above example, the variable ``grampc->sol->status`` is used to check whether new status informations are available.
Subsequently, the function ``grampc_printstatus`` is used to visualize the corresponding informations on the console. 
In the current GRAMPC version, there are status informations concerning the integration scheme, the update of Lagrange multipliers, convergence properties of the augmented Lagrangian and gradient algorithm, and the line search method, see :ref:`sec:AlgOpt:StatusFlags` for more details. 
In addition, the GRAMPC examples provide functions to print key variables such as the system state or the controls into text files. 
These files are stored in the subfolder ``res`` of the example directory.

The ball-on-plate example described above can be compiled by running the following commands in a (Cygwin) terminal:

::

   $ cd <grampc_root>/examples/BallOnPlate
   $ make

The make command compiles the file ``main_BALL_ON_PLATE.c`` and links it against the GRAMPC toolbox, i.e., against the library ``libgrampc.a`` within ``<grampc_root>/libs``. 
Note that compiling an application example in the folder ``<grampc root>/examples/`` requires the previous compilation of the GRAMPC toolbox as described in :ref:`chap:install`.
As a result, the executable ``startMPC`` is generated, which can now be used to solve and/or design the MPC problem.

Using GRAMPC without dynamic memory allocation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

GRAMPC restricts the usage of dynamic memory allocation, i.e. ``calloc`` and ``realloc``, to initialization and option setting, such that no allocations are performed while the MPC is running. 
However, some microcontrollers and embedded devices do not support dynamic memory allocation at all. 
Using GRAMPC on these devices requires to replace all dynamically-sized arrays by fixed-size arrays and to remove all functions that involve dynamic memory allocation.

To this end, a header file ``fixedsize_settings.h`` must be placed in the search path of the compiler. 
This header file defines several constant parameters such as the number of states ``NX``, the number of controls ``NU``, as well as several constant options, e.g. the number of discretization steps ``NHOR``, the number of gradient iterations ``MAXGRADITER``, and the number of multiplier iterations ``MAXMULTITER``. 
Note that these options cannot be changed during run-time, but are fixed at compile-time. 
A template file is provided in the folder ``<grampc_root>/examples/TEMPLATES``.

In addition, the GRAMPC structures must be created on the stack instead of the heap. 
To this end, the macro ``TYPE_GRAMPC_POINTER`` is provided that allows to use the same code both with and without dynamic memory allocation:

.. code-block:: c

   int main()
   {
     TYPE_GRAMPC_POINTER(grampc);
     ...
     grampc_init(&grampc, userparam);
     ...
     grampc_free(&grampc);
   }

The makefile can be called with the parameter ``FIXEDSIZE=1``, which automatically defines the required preprocessor macro ``FIXEDSIZE``. 
Thus compiling and running the ball-on-plate example without dynamic memory allocation is done by executing the following commands in the terminal:

::

   $ cd <grampc_root>/examples/BallOnPlate
   $ make FIXEDSIZE=1
   $ ./startMPC_fixedsize

Note that in this case a separate GRAMPC library named ``libgrampc_fixedsize.a`` is created in the problem folder that depends on the constants defined in ``fixedsize_settings.h``. 
Changing these settings requires to recompile both the library and the application.

Using GRAMPC in Matlab/Simulink
-------------------------------

As already mentioned, the main components of GRAMPC are implemented in plain C to ensure a high level of portability. 
However, GRAMPC also provides a user-friendly interface with Matlab/Simulink to allow for a convenient MPC design.

.. _sec:grampcInterfaceMatlab:

Interface to Matlab
~~~~~~~~~~~~~~~~~~~

Each main component of GRAMPC (cf. :ref:`sec:MainComponents`) has a related Mex routine that is included in the directory ``<grampc_root>/matlab/src``, also see :numref:`fig:grampcInterfaceMatlab`. 
This allows one to run GRAMPC in Matlab/Simulink as well as altering options and parameters without recompilation.

A makefile to compile GRAMPC for use in Matlab/Simulink is provided in ``<grampc_root>/matlab``. 
The makefile compiles the source files to generate object files within ``<grampc_root>/matlab/bin``. 
In order to obtain an actual Mex compilation for a given problem, the object files must be linked against the object file obtained by compiling the problem function, since at least some of these functions depend on the actual problem formulation, e.g. the state dimension :math:`N_{\mb{x}}`.

The m-file ``startMPC.m`` in each of the examples under ``<grampc_root>/examples`` contains a flag ``compile``. 
Setting this flag to 1 leads to a compilation of the problem file and to the generation of the Mex files. 
Setting ``compile`` to 2 leads to an additional recompilation of the toolbox by calling the makefile in the directory ``<grampc_root>/matlab/src``.
The Mex files are stored in the local subfolder ``+CmexFiles``. 
The folder name begins with a plus sign allowing the user to call the functions stored in this
folder using the command ``CmexFiles.<function name>``. 
The S-function files are stored in the local application directory, since Simulink requires the S-functions to be in the Matlab path.


.. figure:: img/InterfaceMatlab.*
    :name: fig:grampcInterfaceMatlab

    Interface of GRAMPC to Matlab/Simulink (gray - C code, white - Matlab code)


The structure of the main components of GRAMPC in C and Matlab for setting options and parameters are slightly different, as it is not allowed (or at least not very elegant) to manipulate the input argument of Mex routines. 
Consequently, each Mex routine returns the manipulated structure variable ``grampc`` as an output argument. 
If, for example, the initial condition :math:`\mb{x}_0` should be set to a specific value in C, the function ``grampc_setparam_real_vector`` must be used, as already discussed in :ref:`chap:grampcStructure:initialization`. 
In Matlab, however, this is done using the Mex routine ``grampc_setparam_Cmex`` with the structure variable ``grampc`` as an input argument. 
The manipulated structure variable ``grampc`` is returned as an output argument including the initial condition :math:`x_0`. 
For instance, the parameter setting in C

.. code-block:: c

   ctypeRNum x0[NX] = {-1,-1};
   grampc_setparam_real_vector(grampc, "x0", x0);

would read as follows in Matlab:

::

   grampc = grampc_setparam_Cmex(grampc,'x0',[-1;-1]);

Note that the Mex routine ``grampc_setparam_Cmex`` does not distinguish between vectors and scalars, but handles the different dimensions of parameters internally.
The same applies to the Mex routine ``grampc_setopt_Cmex`` for changing algorithmic options in GRAMPC. 
The data type of the parameter or option to be set can either be double or the corresponding data type in the parameter structure ``param`` or option structure ``opt``, see also Table :numref:`tab:ListOfParameters` or
Table :numref:`tab:ListOfOptions`.

In order to simplify changing parameters and options in Matlab, GRAMPC also provides the routine ``grampc_update_struct_grampc(grampc,user)`` included in ``<grampc_root>/matlab/mfiles``. 
The purpose of this function is to allow the user to define the options and parameters to be set as structure variable instead of requiring to call the functions ``grampc_setparam_Cmex`` and ``grampc_setopt_Cmex`` manually for each chosen parameter/option. 
In detail, the structure variable ``user`` must contain the substructures ``param`` and ``opt`` that define the parameters and options to be set. 
The corresponding function call under Matlab is as follows:

::

   ...
   %% Parameter definition
   % Initial values of the states
   user.param.x0 = [-1;-1];
   ...

   %% Option definition
   % Basic algorithmic options
   user.opt.Nhor = 10;
   ...

   %% User parameter definition
   % e.g. system parameters or weights for the cost function
   userparam = [100, 10, 1, 100, 10, -0.2, 0.01, -0.1, 0.1];

   %% Grampc initialization
   grampc = CmexFiles.grampc_init_Cmex(userparam);

   %% Update grampc struct while ensuring correct data types
   grampc = grampc_update_struct_grampc(grampc,user);
   ...

Similar to :ref:`chap:grampcStructure:initialization` and :ref:`sec:CompileRun`, the following lines show the mainsteps to run the ball-on-plate example in Matlab. 
An executable version of this example within Matlab can be found in the folder ``<grampc_root>/examples/BallOnPlate``. 
In analogy to the C implementation, the simulation loop and the evaluation are implemented in the main file ``startMPC.m``. 
The parameters and options are defined in the separate file ``initData.m`` that is called within ``startMPC.m`` for the sake of readability and to use the settings directly in the Simulink model,
see :ref:`sec:grampcInterfaceSimulink`. Please note a template file can be found in the folder ``<grampc_root>/examples/TEMPLATES``.

| **Example** **(Matlab code for setting options and parameters, see initData.m)**

::

   %% Parameter definition
   user.param.x0    = [ 0.1, 0.01];
   user.param.xdes  = [-0.2, 0.0];

   % Initial values, setpoints and limits of the inputs
   user.param.u0    = 0;
   user.param.udes  = 0;
   user.param.umax  =  0.0524;
   user.param.umin  = -0.0524;

   % Time variables
   user.param.Thor  = 0.3;         % Prediction horizon

   user.param.dt    = 0.01;        % Sampling time
   user.param.t0    = 0.0;         % time at the current sampling step

   %% Option definition
   user.opt.Nhor        = 10;      % Number of steps for the system integration
   user.opt.MaxMultIter = 3;       % Maximum number of augmented Lagrangian iterations

   % Constraints thresholds
   user.opt.ConstraintsAbsTol = 1e-3*[1 1 1 1];

   %% User parameter definition, e.g. system parameters or weights for the cost function
   userparam = [100, 10, 180, 100, 10, -0.2, 0.2, -0.1, 0.1];

   %% Grampc initialization
   grampc = CmexFiles.grampc_init_Cmex(userparam);

   %% Update grampc struct while ensuring correct data types
   grampc = grampc_update_struct_grampc(grampc,user);

   %% Estimate and set PenaltyMin (optional)
   grampc = CmexFiles.grampc_estim_penmin_Cmex(grampc,1);ot_stat(vec,grampc,phpS);
   ...


| **Example** **(Matlab code for running GRAMPC within an MPC loop, see startMPC.m)**

::

   ...
   %% Initialization
   [grampc,Tsim] = initData;
   CmexFiles.grampc_printopt_Cmex(grampc);
   CmexFiles.grampc_printparam_Cmex(grampc);

   % init solution structure
   vec = grampc_init_struct_sol(grampc, Tsim);

   % init plots and store figure handles
   phpP = grampc_init_plot_pred(grampc,figNr);     figNr = figNr+1;
   phpT = grampc_init_plot_sim(vec,figNr);         figNr = figNr+1;
   phpS = grampc_init_plot_stat(vec,grampc,figNr); figNr = figNr+1;

   %% MPC loop
   i = 1;
   while 1
     % set current time and current state
     grampc = CmexFiles.grampc_setparam_Cmex(grampc,'t0',vec.t(i));
     grampc = CmexFiles.grampc_setparam_Cmex(grampc,'x0',vec.x(:,i));

     % run MPC and save results
     [grampc,vec.CPUtime(i)] = CmexFiles.grampc_run_Cmex(grampc);
     vec = grampc_update_struct_sol(grampc, vec, i);

     % print solver status
     printed = CmexFiles.grampc_printstatus_Cmex(grampc.sol.status,'Error');

     % check for end of simulation
     if i+1 > length(vec.t)
       break;
     end

     % simulate system
     [~,xtemp] = ode45(@CmexFiles.grampc_ffct_Cmex,vec.t(i)+[0 double(grampc.param.dt)],
                 vec.x(:,i),odeopt,vec.u(:,i),vec.p(:,i),grampc.param,grampc.userparam);
     vec.x(:,i+1) = xtemp(end,:);

     % evaluate time-dependent constraints
     vec.constr(:,i) = CmexFiles.grampc_ghfct_Cmex(vec.t(i), vec.x(:,i), vec.u(:,i),
                                            vec.p(:,i), grampc.param, grampc.userparam);

     % update iteration counter
     i = i + 1;

     % plot data
     grampc_update_plot_pred(grampc,phpP);
     grampc_update_plot_sim(vec,phpT);
     grampc_update_plot_stat(vec,grampc,phpS);
   end

Similar to the C example in :ref:`sec:CompileRun`, the structure variable ``grampc`` is initialized before the options as well as optional parameters are set. 
In addition, the plot functions (see :ref:`sec:Plotfunctions`) are initialized before GRAMPC is started within an MPC loop, where the current state of the system (new initial condition) is provided to GRAMPC. 
After computing the new controls, the status of GRAMPC is printed, see :ref:`sec:AlgOpt:StatusFlags` for more details.
Subsequently, a reference integration of the system is performed and the constraints are evaluated before the plots are updated.

.. _sec:grampcInterfaceSimulink:

Interface to Matlab/Simulink
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

GRAMPC also allows a Matlab/Simulink integration via the S-function ``grampc_run_Sfct.c`` (also included in the directory ``<grampc_root>/matlab/src``). 
A corresponding Simulink template can be found in the folder ``<grampc_root>/examples/TEMPLATES`` for a number of Matlab versions.
The directory also contains the m-file ``initData_TEMPLATE.m`` which can be used for initializing GRAMPC's options and parameters, as mentioned in the previous subsection. 
The build procedure of the Mex routines additionally compiles the S-function for the Simulink block.

The Matlab/Simulink model of GRAMPC is shown in :numref:`fig:grampcSimulink`. 
The block ``MPC-Subsystem`` contains algorithmic components of GRAMPC (implemented within the S-function ``grampc_run_Sfct.c``). 
The block ``Click to init grampc`` must be executed by a double-click in order to initialize the structure variable that is required by the Matlab/Simulink model. 
This generates also the Simulink-specific structure variable ``grampc_sdata``. 
For the sake of convenience, the blocks ``Click to compile toolbox`` and ``Click to compile probfct`` are included in the model to be able to compile the GRAMPC toolbox and the specific problem directly from Matlab/Simulink.

The block ``System function`` is a Matlab Function block which implements the system dynamics in order to numerically integrate the system dynamics after each MPC step :math:`k` for the sampling time :math:`\Delta t` and to return the new state value :math:`\mb{x}_{k+1}` corresponding to the next sampling instant :math:`t_{k+1}` that is fed back to the MPC block.

Furthermore, the S-function ``grampc_run_Sfct.c`` satisfies the additional restrictions of the Matlab code generator. 
Therefore, the block can be used in models implemented for running on various hardware platforms, such as dSpace real-time systems. 
Please note that especially in case of dSpace applications, the include folders ``<grampc_root>/include`` and ``<grampc_root>/matlab/include`` as well as all C source files in ``<grampc_root>/src``,
the source file of the S-function ``<grampc_root>/matlab/src/grampc_runSfct.c`` and the problem function must be listed as additional build information in the ``Model Configuration Parameters`` of the Simulink model under ``Code Generation / Custom Code``. 
It is recommended to use absolute paths at least for the S-function file.

.. figure:: img/grampc_Simulink.*
    :name: fig:grampcSimulink

    Matlab/Simulink model of GRAMPC.

.. _sec:Plotfunctions:

Plot functions
~~~~~~~~~~~~~~

GRAMPC offers various plot functions in the folder ``<grampc_root>/matlab/mfiles``. Each plot must be initialized at first using the m-files ``grampc_init_plot_*.m``. 
During the simulation the plots can be updated by the m-files ``grampc_update_plot_*.m``. 
Beside the trajectories of the simulated system dynamics (file ending \*=sim) and trajectories along the prediction horizon (file ending \*=pred), also some statistics (file ending \*=stat) can be plotted. 
When solving OCPs instead of MPC problems, the plot along the prediction horizon shows the actual results. 
The plotted quantities depend on the parameter and option settings of GRAMPC, i.e. whether constraints are considered or not. 
The available plots are listed in more detail in the following lines. 
(Also see the example problems under ``<grampc_root>/examples`` for code samples on how to use the plot routines.)

System dynamics plot (plot_sim)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

-  **States**: This plot illustrates the trajectories of the state :math:`\mb{x}` along the simulation time.

-  **Adjoint states**: This plot illustrates the trajectories of the adjoint state :math:`\mb{\lambda}` along the simulation time.

-  **Controls**: This plot illustrates the trajectories of the controls :math:`\mb{u}` along the simulation time.

-  **Constraints**: This plot appears only if equality and/or inequality constraints are defined (:math:`{N_{\mb{g}}}` and/or :math:`{N_{\mb{h}}}` is larger than zero as specified in ``ocp_dim``). 
   The plot shows the trajectories of the constraints :math:`\mb{g}` and :math:`\mb{h}` along the simulation time.

-  **Lagrange multipliers**: This plot appears only if equality and/or inequality constraints are defined. 
   The plot shows the trajectories of the multipliers :math:`\mb{\mu}_{\mb{g}}` and :math:`\mb{\mu}_{\mb{h}}` along the simulation time.
   If any Lagrange multiplier reaches the limit :math:`\mu_\text{max}` (specified by ``MultiplierMax``), it indicates that the penalty parameters are too high or that the problem is not well-conditioned or that the costs are badly scaled.

-  **Penalty parameters**: This plot appears only if equality and/or inequality constraints are defined. 
   The plot shows the trajectories of the penalties :math:`\mb{c}_{\mb{g}}` and :math:`\mb{c}_{\mb{h}}` along the simulation time. 
   If any penalty reaches the maximum value :math:`c_\text{max}`, set by ``PenaltyMax``, it indicates that either the limit is not high enough or the update is too aggressive.

Prediction plot (plot_pred)
^^^^^^^^^^^^^^^^^^^^^^^^^^^

-  **Predicted states**: This plot illustrates the trajectories of the state :math:`\mb{x}` along the prediction horizon.

-  **Predicted adjoint states**: This plot illustrates the trajectories of the adjoint state :math:`\mb{\lambda}` along the prediction horizon.

-  **Predicted controls**: This plot illustrates the trajectories of the controls :math:`\mb{u}` along the prediction horizon.

-  **Predicted constraints**: This plot appears only if (terminal) equality and/or inequality constraints are defined. 
   The plot shows the predicted violation of the equality constraints :math:`\mb{g}` and inequality constraints :math:`\mb{\max}(\mb{h},\mb{0})` 
   along the prediction horizon and the predicted violation of the terminal equality constraints :math:`{\mb{g}_{T}}` and inequality
   constraints :math:`\mb{\max}(\mb{h}_T,\mb{0})` at the end of the prediction horizon. 
   Please note that except for OCPs, these are not the actual but predicted internal constraint violations of the current GRAMPC iteration.

-  **Lagrange multipliers**: This plot appears only if (terminal)
   equality and/or inequality constraints are defined. 
   The plot shows the trajectories of the multipliers :math:`\mb{\mu}_{\mb{g}}` and
   :math:`\mb{\mu}_{\mb{h}}` along the prediction horizon and the multipliers
   :math:`{\mb{\mu}_{\mb{g}_T}}` and :math:`{\mb{\mu}_{\mb{h}_T}}`. 
   If any Lagrange multiplier reaches the limit :math:`\mu_\text{max}`, set by ``MultiplierMax``, it
   indicates that the penalty parameters are too high or that the problem is not well-conditioned or that the costs are badly scaled.

-  **Penalty parameters**: This plot appears only if (terminal) equality and/or inequality constraints are defined. 
   The plot shows the trajectories of the penalties :math:`\mb{c}_{\mb{g}}` and :math:`\mb{c}_{\mb{h}}` 
   along the prediction horizon and the penalties :math:`{\mb{c}_{\mb{g}_T}}` and :math:`{\mb{c}_{\mb{h}_T}}`. 
   If any penalty reaches the maximum value :math:`c_\text{max}` set by ``PenaltyMax``, it indicates that either the limit is not high enough or 
   the update is too aggressive, see also :ref:`sec:AlgOpt:UpdateMultPen`.

Statistics plot (plot_stat)
^^^^^^^^^^^^^^^^^^^^^^^^^^^

-  **Costs**: This plot illustrates the costs :math:`J` along the simulation time or along the augmented Lagrangian iterations. 
   If constraints are defined, the augmented costs :math:`\bar{J}` are shown as well.

-  **Computation time**: This plot illustrates the computation time of one MPC or optimization step of GRAMPC along the simulation time or along the augmented Lagrangian iterations. 
   The time measurement is done in the function ``grampc_run_Cmex.c`` using operation system specific timer functions.
   Consequently, the time excludes the overhead resulting from the Mex interface as well as the time consumed by the plot functions.

-  **Line search step size**: This plot illustrates the step size :math:`\alpha` of the last gradient iteration along the simulation time or along the augmented Lagrangian iterations. 
   If the adaptive line search is used (see :ref:`sec:AlgOpt:LineSearchAdaptive`), the plot also illustrates the three corresponding sample points :math:`\alpha_1`, :math:`\alpha_2`, and :math:`\alpha_3`. 
   A step size equal to the maximum or minimum value :math:`\alpha_\text{max}` or :math:`\alpha_\text{min}` indicates that these values may have to be adapted or the problem may have to be scaled. 
   Additionally, if the explicit line search is chosen and the fallback strategy is not activated (see :ref:`sec:AlgOpt:LineSearchExplicit` and :ref:`sec:AlgOpt:LineSearchFallback`), a frequent use of the initial value :math:`\alpha_\text{init}` indicates an ill-conditioned problem.

-  **Gradient iterations**: This plot appears only if the option ``ConvergenceCheck`` is set to ``on``. 
   It illustrates the number of executed gradient iterations along the simulation time or along the augmented Lagrangian iterations. 
   In particular, the plot depicts whether the maximum number of gradient iterations :math:`j_\text{max}` is reached or the convergence check caused a premature termination of the minimization.

-  **Prediction horizon**: This plot appears only if the option ``OptimTime`` is set to ``on``. 
   It illustrates the prediction horizon :math:`T` along the simulation time or along the augmented Lagrangian iterations. 
   In shrinking horizon applications the value should decrease linearly after a short settling phase.

-  **Norm of constraints over horizon**: This plot appears only if constraints are defined. 
   It illustrates the norm :math:`\frac{1}{T}\sqrt{\|\mb{g}\|_{L_2}^2+\|\mb{\max}( {\mb{h}},\mb{0})\|_{L_2}^2 +\| {\mb{g}_T}\|_{2}^2+\|\mb{\max}( {\mb{h}_T},\mb{0})\|_{2}^2 }`
   over all predicted constraints plotted over the simulation time or the augmented Lagrangian iterations. 
   Especially when solving OCPs, the value should decrease continuously.

-  **Norm of penalty parameters over horizon**: This plot appears only if the number of equality :math:`{N_{\mb{g}}}`, inequality :math:`{N_{\mb{h}}}`, terminal equality :math:`{N_{\mb{g}_T}}` or terminal inequality :math:`{N_{\mb{h}_T}}` constraints is not zero. 
   It illustrates the norm :math:`\frac{1}{T}\sqrt{\|\mb{\bar c}\|_{L_2}}` over all predicted penalty parameters along the simulation time or along the augmented Lagrangian iterations.

-  **Terminal constraints**: This plot appears only if terminal constraints are defined. 
   It illustrates the violation of the terminal equality constraints :math:`{\mb{g}_{T}}` and inequality constraints :math:`\mb{\max}(\mb{h}_T,\mb{0})` along the simulation time or along the augmented Lagrangian iterations in case of OCPs.

-  **Terminal Lagrangian multipliers**: This plot appears only if terminal constraints are defined. 
   It illustrates the multipliers :math:`{\mb{\mu}_{\mb{g}_T}}` and :math:`{\mb{\mu}_{\mb{h}_T}}` along the simulation time or along the augmented Lagrangian iterations in case of OCPs.

-  **Terminal penalty parameters**: This plot appears only if terminal constraints are defined. 
   It illustrates the penalties :math:`{\mb{c}_{\mb{g}_T}}` and :math:`{\mb{c}_{\mb{h}_T}}` along the simulation time or along the augmented Lagrangian iterations in case of OCPs.

.. footbibliography::