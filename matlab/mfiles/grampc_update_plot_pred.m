function grampc_update_plot_pred(grampc,ph,idx,decimation)
% This function updates the prediction plot of GRAMPC. The figure
% specified via the plot handle ph must have been generated by the
% function grampc_init_plot_pred.
%
% Input arguments are:
% 1) grampc - GRAMPC struct
% 2) ph - plot handle generated by grampc_init_plot_pred
% 3) idx - index struct that specifies the quantities to be plotted (optional)
% 4) decimation - factor for downsampling the plot (optional
%
% This file is part of GRAMPC - (https://sourceforge.net/projects/grampc/)
%
% GRAMPC -- A software framework for embedded nonlinear model predictive
% control using a gradient-based augmented Lagrangian approach
%
% Copyright (C) 2014-2018 by Tobias Englert, Knut Graichen, Felix Mesmer, 
% Soenke Rhein, Andreas Voelz, Bartosz Kaepernick (<v2.0), Tilman Utz (<v2.0). 
% Developed at the Institute of Measurement, Control, and Microtechnology, 
% Ulm University. All rights reserved.
%
% GRAMPC is free software: you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License as
% published by the Free Software Foundation, either version 3 of
% the License, or (at your option) any later version.
%
% GRAMPC is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
% GNU Lesser General Public License for more details.
%
% You should have received a copy of the GNU Lesser General Public
% License along with GRAMPC. If not, see <http://www.gnu.org/licenses/>.

% Check input arguments
if nargin < 3 || isempty(idx)
    idx.States = 1:size(grampc.rws.x,1);
    idx.Controls = 1:size(grampc.rws.u,1);
    idx.Constraints = 1:size(grampc.rws.cfct,1);
end
if nargin < 4 || isempty(decimation)
    decimation = 1;
end

% Specify terminal constraints
idx.TConstraints = idx.Constraints(idx.Constraints>(grampc.param.Ng+grampc.param.Nh));
idx.gConstraints = idx.Constraints(idx.Constraints<=(grampc.param.Ng+grampc.param.Nh));

% compute additional data in case of an adaptive line search
if grampc.opt.LineSearchType == 0
    
    % Extract data from grampc Struct and compute cost interpoaltion
    aa = cell(1,grampc.opt.MaxGradIter);
    jj = cell(1,grampc.opt.MaxGradIter);
    a = cell(1,grampc.opt.MaxGradIter);
    j = cell(1,grampc.opt.MaxGradIter);
    aopt = cell(1,grampc.opt.MaxGradIter);
    jopt = cell(1,grampc.opt.MaxGradIter);
    for i = 1:grampc.opt.MaxGradIter
        [aa{i},jj{i}] = cost_approximation(grampc.rws.lsAdapt(1+(i-1)*8:i*8));
        j{i}    = grampc.rws.lsAdapt(5+(i-1)*8:i*8-1);
        a{i}    = grampc.rws.lsAdapt(1+(i-1)*8:i*8-5);
        jopt{i} = grampc.rws.lsAdapt(i*8);
        aopt{i} = grampc.rws.lsAdapt(4+(i-1)*8);
    end
    
%     % Set limits of the plot
%     xmin = a{1}(1);
%     xmax = a{1}(end);
%     ymin = min(j{1});
%     ymax = max(j{1});
%     for i = 2:grampc.opt.MaxGradIter
%         xmin = min(xmin,a{i}(1));
%         xmax = max(xmax,a{i}(end));
%         ymin = min(ymin,min(jopt{i},min(j{i})));
%         ymax = max(ymax,max(j{i}));
%     end
%     if ~(isnan(xmin) || isnan(xmax) || isnan(ymin) || isnan(ymax)) && ymax ~= ymin && xmax ~= xmin
%         subplot_ls = get(ph.s4a(1),'Parent');
%         xlim(subplot_ls,[xmin-abs(xmax-xmin)*0.1 xmax+abs(xmax-xmin)*0.1]);
%         ylim(subplot_ls,[ymin-abs(ymax-ymin)*0.1 ymax+abs(ymax-ymin)*0.1]);
%     end
    
    % Update the handles
    for i = 1:grampc.opt.MaxGradIter
        set(ph.s4a(i),'XData',aa{i},'YData',jj{i});
        set(ph.s4b(i),'XData',a{i},'YData',j{i});
        set(ph.s4c(i),'XData',aopt{i},'YData',jopt{i});
    end
end

    % Update handles
    % plot states and adj. states
    for i = idx.States
        set(ph.s1(i),'YData',grampc.rws.x(i,1:decimation:end))
        set(ph.s1(i),'XData',grampc.rws.t(1:decimation:end))
        
        set(ph.s2(i),'YData',grampc.rws.adj(i,1:decimation:end))
        set(ph.s2(i),'XData',grampc.rws.t(1:decimation:end))
    end
    % plot controls
    for i = idx.Controls
        set(ph.s3(i),'YData',grampc.rws.u(i,1:decimation:end))
        set(ph.s3(i),'XData',grampc.rws.t(1:decimation:end))
    end
    
    for i = idx.gConstraints
        % Constraints
        if i <= grampc.param.Ng
            set(ph.s5a(i),'YData',grampc.rws.cfct(i,1:decimation:end))
        else
            set(ph.s5a(i),'YData',max(grampc.rws.cfct(i,1:decimation:end),0))
        end
        set(ph.s5a(i),'XData',grampc.rws.t(1:decimation:end))
        % mult
        set(ph.s6a(i),'YData',grampc.rws.mult(i,1:decimation:end))
        set(ph.s6a(i),'XData',grampc.rws.t(1:decimation:end))
        % pen
        set(ph.s7a(i),'YData',grampc.rws.pen(i,1:decimation:end))
        set(ph.s7a(i),'XData',grampc.rws.t(1:decimation:end))
    end
   
    % Terminal constraints
    for i = idx.TConstraints
        % Constraints
        if i <= grampc.param.Ng+grampc.param.Nh+grampc.param.NgT
            set(ph.s5b(i-idx.TConstraints(1)+1),'YData',grampc.rws.cfct(i,end))
        else
            set(ph.s5b(i-idx.TConstraints(1)+1),'YData',max(grampc.rws.cfct(i,end),0))
        end
        set(ph.s5b(i-idx.TConstraints(1)+1),'XData',grampc.rws.t(end))
        % mult
        set(ph.s6b(i-idx.TConstraints(1)+1),'YData',grampc.rws.mult(i,end))
        set(ph.s6b(i-idx.TConstraints(1)+1),'XData',grampc.rws.t(end))
        % pen
        set(ph.s7b(i-idx.TConstraints(1)+1),'YData',grampc.rws.pen(i,end))
        set(ph.s7b(i-idx.TConstraints(1)+1),'XData',grampc.rws.t(end))
    end
    
    if(grampc.opt.OptimTime == 1)
        xlim(get(ph.s1(1),'Parent'),[grampc.rws.t(1),grampc.rws.t(end)])
    end
end

function [alpha,J] = cost_approximation(lsAdapt)
% This function interpolates the cost in case of the adaptive linesearch

j = lsAdapt(5:7);
a = lsAdapt(1:3);

c0 = (j(3)*a(1)*(a(1)-a(2))*a(2)+a(3)*(j(1)*a(2)*(a(2)-a(3))+j(2)*a(1)*(-a(1)+a(3))))/((a(1)-a(2))*(a(1)-a(3))*(a(2)-a(3)));
c1 = (j(3)*(-(a(1)*a(1))+(a(2)*a(2)))+j(2)*((a(1)*a(1))-(a(3)*a(3)))+j(1)*(-(a(2)*a(2))+(a(3)*a(3))))/((a(1)-a(2))*(a(1)-a(3))*(a(2)-a(3)));
c2 = ((j(1)-j(3))/(a(1)-a(3))+(-j(2)+j(3))/(a(2)-a(3)))/(a(1)-a(2));

alpha = linspace(a(1),a(3),19);
J     = c2.*alpha.^2 + c1.*alpha + c0;
end