function grampc_update_plot_pred(grampc,ph,idx,decimation)
% This function updates the prediction plot of GRAMPC. The figure
% specified via the plot handle ph must have been generated by the
% function grampc_init_plot_pred.
%
% Input arguments are:
% 1) grampc - GRAMPC struct
% 2) ph - plot handle generated by grampc_init_plot_pred
% 3) idx - index struct that specifies the quantities to be plotted (optional)
% 4) decimation - factor for downsampling the plot (optional
%
% This file is part of GRAMPC - (https://github.com/grampc/grampc)
%
% GRAMPC -- A software framework for embedded nonlinear model predictive
% control using a gradient-based augmented Lagrangian approach
%
% Copyright 2014-2025 by Knut Graichen, Andreas Voelz, Thore Wietzke,
% Tobias Englert (<v2.3), Felix Mesmer (<v2.3), Soenke Rhein (<v2.3),
% Bartosz Kaepernick (<v2.0), Tilman Utz (<v2.0).
% All rights reserved.
%
% GRAMPC is distributed under the BSD-3-Clause license, see LICENSE.txt

% Check input arguments
if nargin < 3 || isempty(idx)
    idx.States = 1:size(grampc.rws.x,1);
    idx.Controls = 1:size(grampc.rws.u,1);
    idx.Constraints = 1:size(grampc.rws.cfct,1);
end
if nargin < 4 || isempty(decimation)
    decimation = 1;
end

% Specify terminal constraints
idx.TConstraints = idx.Constraints(idx.Constraints>(grampc.param.Ng+grampc.param.Nh));
idx.gConstraints = idx.Constraints(idx.Constraints<=(grampc.param.Ng+grampc.param.Nh));

% compute additional data in case of an adaptive line search
if grampc.opt.LineSearchType == 0
    
    % Extract data from grampc Struct and compute cost interpoaltion
    aa = cell(1,grampc.opt.MaxGradIter);
    jj = cell(1,grampc.opt.MaxGradIter);
    a = cell(1,grampc.opt.MaxGradIter);
    j = cell(1,grampc.opt.MaxGradIter);
    aopt = cell(1,grampc.opt.MaxGradIter);
    jopt = cell(1,grampc.opt.MaxGradIter);
    for i = 1:grampc.opt.MaxGradIter
        [aa{i},jj{i}] = cost_approximation(grampc.rws.lsAdapt(1+(i-1)*8:i*8));
        j{i}    = grampc.rws.lsAdapt(5+(i-1)*8:i*8-1);
        a{i}    = grampc.rws.lsAdapt(1+(i-1)*8:i*8-5);
        jopt{i} = grampc.rws.lsAdapt(i*8);
        aopt{i} = grampc.rws.lsAdapt(4+(i-1)*8);
    end
    
    %     % Set limits of the plot
    %     xmin = a{1}(1);
    %     xmax = a{1}(end);
    %     ymin = min(j{1});
    %     ymax = max(j{1});
    %     for i = 2:grampc.opt.MaxGradIter
    %         xmin = min(xmin,a{i}(1));
    %         xmax = max(xmax,a{i}(end));
    %         ymin = min(ymin,min(jopt{i},min(j{i})));
    %         ymax = max(ymax,max(j{i}));
    %     end
    %     if ~(isnan(xmin) || isnan(xmax) || isnan(ymin) || isnan(ymax)) && ymax ~= ymin && xmax ~= xmin
    %         subplot_ls = get(ph.s4a(1),'Parent');
    %         xlim(subplot_ls,[xmin-abs(xmax-xmin)*0.1 xmax+abs(xmax-xmin)*0.1]);
    %         ylim(subplot_ls,[ymin-abs(ymax-ymin)*0.1 ymax+abs(ymax-ymin)*0.1]);
    %     end
    
    % Update the handles
    for i = 1:grampc.opt.MaxGradIter
        set(ph.s4a(i),'XData',aa{i},'YData',jj{i});
        set(ph.s4b(i),'XData',a{i},'YData',j{i});
        set(ph.s4c(i),'XData',aopt{i},'YData',jopt{i});
    end
end

% Update handles
% plot states and adj. states
for i = idx.States
    set(ph.s1(i),'YData',grampc.rws.x(i,1:decimation:end))
    set(ph.s1(i),'XData',grampc.rws.t(1:decimation:end))
    
    set(ph.s2(i),'YData',grampc.rws.adj(i,1:decimation:end))
    set(ph.s2(i),'XData',grampc.rws.t(1:decimation:end))
end
adapt_ylim(grampc.rws.x(idx.States,:),ph.s1);
adapt_ylim(grampc.rws.adj(idx.States,:),ph.s2);


% plot controls
for i = idx.Controls
    set(ph.s3(i),'YData',grampc.rws.u(i,1:decimation:end))
    set(ph.s3(i),'XData',grampc.rws.t(1:decimation:end))
end
adapt_ylim(grampc.rws.u(idx.Controls,:),ph.s3);



if ~isempty(idx.Constraints)
    
    % General constraints
    if ~isempty(idx.gConstraints)
        % Evaluate the constraints over horizon
        ipred = 1:decimation:grampc.opt.Nhor;
        constr = zeros(grampc.param.Ng+grampc.param.Nh,length(ipred));
        if grampc.opt.ScaleProblem == 1
            xpred = grampc.rws.x.*repmat(grampc.opt.xScale(:),1,grampc.opt.Nhor)+repmat(grampc.opt.xOffset(:),1,grampc.opt.Nhor);
            upred = grampc.rws.u.*repmat(grampc.opt.uScale(:),1,grampc.opt.Nhor)+repmat(grampc.opt.uOffset(:),1,grampc.opt.Nhor);
            if ~isempty(grampc.rws.p)
                ppred = grampc.rws.p'.*grampc.opt.pScale+grampc.opt.pOffset;
            else
                ppred = grampc.rws.p;
            end
        else
            xpred = grampc.rws.x;
            upred = grampc.rws.u;
            ppred = grampc.rws.p;
        end
        for i = ipred
            constr(:,i) = CmexFiles.grampc_ghfct_Cmex(grampc.rws.t(i), xpred(:,i), upred(:,i), ppred, grampc.param, grampc.userparam);
        end
        
        for i = idx.gConstraints
            % Constraints
            set(ph.s5a(i),'YData',constr(i,:))
            set(ph.s5a(i),'XData',grampc.rws.t(1:decimation:end))
            % mult
            set(ph.s6a(i),'YData',grampc.rws.mult(i,1:decimation:end))
            set(ph.s6a(i),'XData',grampc.rws.t(1:decimation:end))
            % pen
            set(ph.s7a(i),'YData',grampc.rws.pen(i,1:decimation:end))
            set(ph.s7a(i),'XData',grampc.rws.t(1:decimation:end))
        end
    else
        constr = 0;
    end
    
    % Terminal constraints
    if ~isempty(idx.TConstraints)
        
        % Evaluate terminal constraints
        if grampc.opt.ScaleProblem == 1
            xend = grampc.rws.x(:,end).*grampc.opt.xScale+grampc.opt.xOffset;
            if ~isempty(grampc.rws.p)
                ppred = grampc.rws.p.*grampc.opt.pScale+grampc.opt.pOffset;
            else
                ppred = grampc.rws.p;
            end
        else
            xend = grampc.rws.x(:,end);
            ppred = grampc.rws.p;
        end
        Tconstr = CmexFiles.grampc_gThTfct_Cmex(grampc.rws.t(end), xend, ppred, grampc.param, grampc.userparam);
        
        for i = idx.TConstraints
            % Constraints
            set(ph.s5b(i-idx.TConstraints(1)+1),'YData',Tconstr(i-idx.TConstraints(1)+1))
            set(ph.s5b(i-idx.TConstraints(1)+1),'XData',grampc.rws.t(end))
            % mult
            set(ph.s6b(i-idx.TConstraints(1)+1),'YData',grampc.rws.mult(i,end))
            set(ph.s6b(i-idx.TConstraints(1)+1),'XData',grampc.rws.t(end))
            % pen
            set(ph.s7b(i-idx.TConstraints(1)+1),'YData',grampc.rws.pen(i,end))
            set(ph.s7b(i-idx.TConstraints(1)+1),'XData',grampc.rws.t(end))
        end
    else
        Tconstr = 0;
    end
    ymax = max([max(max(constr(idx.gConstraints,:))),max(Tconstr(idx.TConstraints-double(grampc.param.Ng+grampc.param.Nh))),0]);
    ymin = min([min(min(constr(idx.gConstraints,:))),min(Tconstr(idx.TConstraints-double(grampc.param.Ng+grampc.param.Nh))),0]);

    
    if(isfield(ph,'s6a'))
        adapt_ylim([ymax ymin],ph.s5a);
        adapt_ylim(grampc.rws.mult(idx.Constraints,:),ph.s6a);
        adapt_ylim(grampc.rws.pen(idx.Constraints,:),ph.s7a);
    else
        adapt_ylim([ymax ymin],ph.s5b);
        adapt_ylim(grampc.rws.mult(idx.Constraints,:),ph.s6b);
        adapt_ylim(grampc.rws.pen(idx.Constraints,:),ph.s7b);
    end
end


if(grampc.opt.OptimTime == 1)
    xlim(get(ph.s1(1),'Parent'),[grampc.rws.t(1),grampc.rws.t(end)])
end
end

function [alpha,J] = cost_approximation(lsAdapt)
% This function interpolates the cost in case of the adaptive linesearch

j = lsAdapt(5:7);
a = lsAdapt(1:3);

d = a(3)-a(2);
c2 = (j(1)-2*j(2)+j(3))/(2*d*d);
c1 = (d*(-j(1) + j(3)) - 2*(j(1) - 2*j(2) + j(3))*a(2))/(2*d*d);
c0 = (2*d*d*j(2) + d*(j(1) - j(3))*a(2) + (j(1) - 2*j(2) + j(3))*a(2)*a(2))/(2*d*d);

alpha = linspace(a(1),a(3),19);
J     = c2.*alpha.^2 + c1.*alpha + c0;
end