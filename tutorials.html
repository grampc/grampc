<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Tutorials &#8212; grampc 2.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css?v=def86cc0" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    
    <script src="_static/documentation_options.js?v=57236720"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>window.MathJax = {"tex": {"macros": {"mb": ["\\boldsymbol{#1}", 1]}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Appendix" href="appendix.html" />
    <link rel="prev" title="Usage of GRAMPC" href="usage.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="prf-prf.html" title="Proof Index"
             >Proof</a> |</li>
        <li class="right" >
          <a href="appendix.html" title="Appendix"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="usage.html" title="Usage of GRAMPC"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">grampc 2.3 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tutorials</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="tutorials">
<span id="chap-tutorials"></span><h1>Tutorials<a class="headerlink" href="#tutorials" title="Link to this heading">¶</a></h1>
<p>This chapter presents some application examples of GRAMPC and how to
tune GRAMPC to improve the performance compared to the default
settings. In addition to a model predictive control and an optimal
control problem, a moving horizon estimation example is presented.
Please note that the plot functions, described in <a class="reference internal" href="usage.html#sec-plotfunctions"><span class="std std-ref">Plot functions</span></a>, and the status of GRAMPC, see <a class="reference internal" href="algorithm.html#sec-algopt-statusflags"><span class="std std-ref">Status flags</span></a>, also provide important
information for tuning GRAMPC.</p>
<section id="model-predictive-control-of-a-pmsm">
<span id="sec-tut-pmsm"></span><h2>Model predictive control of a PMSM<a class="headerlink" href="#model-predictive-control-of-a-pmsm" title="Link to this heading">¶</a></h2>
<p>The torque or current control of a permanent magnet synchronous machine
(PMSM) is a challenging example for nonlinear constrained model
predictive control. The following subsections illustrate the problem
formulation as well as useful options of GRAMPC to improve the control
performance. Corresponding m and C files can be found in the folder <code class="docutils literal notranslate"><span class="pre">&lt;grampc_root&gt;/examples/PMSM</span></code>.</p>
<section id="problem-formulation">
<h3>Problem formulation<a class="headerlink" href="#problem-formulation" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="fig-pmsm-constr-unscaled">
<img alt="img/tikz/ext/ext_PMSM_constr_unscaled.*" src="img/tikz/ext/ext_PMSM_constr_unscaled.*" />
<figcaption>
<p><span class="caption-number">Fig. 7 </span><span class="caption-text">Simulated MPC trajectories for the PMSM example with default settings.</span><a class="headerlink" href="#fig-pmsm-constr-unscaled" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The system dynamics of a PMSM <a class="footnote-reference brackets" href="#footcite-englert-cep-2018" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<div class="math notranslate nohighlight" id="equation-eq-tut-pmsm-model">
<span class="eqno">(20)<a class="headerlink" href="#equation-eq-tut-pmsm-model" title="Link to this equation">¶</a></span>\[\begin{split}L_\text{d}\tfrac{{\rm d}}{{\rm d}t}i_\text{d} &amp;= -R i_\text{d}+L_\text{q}\omega i_\text{q}+u_\text{d}\\
L_\text{q}\tfrac{{\rm d}}{{\rm d}t}i_\text{q} &amp;= -R i_\text{q}-L_\text{d}\omega i_\text{d}-\omega\psi_\text{p}+u_\text{q} \\
J\tfrac{{\rm d}}{{\rm d}t}\omega &amp;= \left(\tfrac{3}{2}z_\text{p}\left(\psi_\text{p}i_\text{q} +
i_\text{d}i_\text{q}(L_\text{d} - L_\text{q})\right)-\tfrac{\mu_\text{f}}{z_\text{p}}\omega-T_\text{L}\right)z_\text{p}\\
\tfrac{{\rm d}}{{\rm d}t}\phi &amp;= \omega\end{split}\]</div>
<p>is given in the dq-coordinates. The system state
<span class="math notranslate nohighlight">\(\mb{x} = [i_\text{d},i_\text{q},\omega,\phi]^\mathsf{T}\)</span>
comprises the dq-currents, the electrical rotor speed as well as the
electrical angle. The dq-voltages serve as controls
<span class="math notranslate nohighlight">\(\mb{u} = [u_\text{d},u_\text{q}]^\mathsf{T}\)</span>. Further
system parameters are the stator resistance <span class="math notranslate nohighlight">\(R = 3.5\,\Omega\)</span>,
the number of pole-pairs <span class="math notranslate nohighlight">\(z_\text{p} = 3\)</span>, the permanent magnet
flux <span class="math notranslate nohighlight">\(\psi_p = 0.17\,\mathrm{V\,s}\)</span>, the dq-inductivities
<span class="math notranslate nohighlight">\(L_\text{d}=L_\text{q}=17.5\,\mathrm{mH}\)</span>, the moment of
inertia <span class="math notranslate nohighlight">\(J= 0.9\,\mathrm{g\,m^2}\)</span> as well as the friction
coefficient <span class="math notranslate nohighlight">\(\mu_\text{f}=0.4\,\mathrm{mN\,m\,s}\)</span>.</p>
<p>The magnitude of the dq-currents is limited by the maximum current
<span class="math notranslate nohighlight">\(I_\text{max}=10\,A\)</span>, i.e.</p>
<div class="math notranslate nohighlight" id="equation-eq-tut-pmsm-stateconstr">
<span class="eqno">(21)<a class="headerlink" href="#equation-eq-tut-pmsm-stateconstr" title="Link to this equation">¶</a></span>\[i_\text{abs} =i_\text{d}^2+i_\text{q}^2 \leq I_\text{max}^2\,,\]</div>
<p>in order prevent damage of the electrical components. Another constraint
concerns the dq-voltages. Through the modulation stage between the
controller and the voltage source inverter, the dq-voltages are limited
inside the circle</p>
<div class="math notranslate nohighlight" id="equation-eq-tut-pmsm-inputconstr">
<span class="eqno">(22)<a class="headerlink" href="#equation-eq-tut-pmsm-inputconstr" title="Link to this equation">¶</a></span>\[u_\text{abs} = u_\text{d}^2+u_\text{q}^2 \leq U_\text{max}^2\]</div>
<p>with the maximum voltage <span class="math notranslate nohighlight">\(U_\text{max}=323\,\mathrm{V}\)</span>.</p>
<p>The optimal control problem</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\min_{\mb{u}} \quad &amp; J(\mb{u};\mb{x}_k) = \int_0^T l(\mb{x}(\tau), \mb{u}(\tau)) \, {\rm d}\tau\\\textrm{s.t.} \quad &amp; \mb{\dot x}(\tau) = \mb{f}(\mb{x}(\tau), \mb{u}(\tau)) \,, \quad \mb{x}(0) = \mb{x}_k\\&amp; h_1(\mb{x} (\tau)) = x_1(\tau)^2 +  x_2(\tau)^2 - I_\text{max}^2 \leq 0\\&amp; h_2(\mb{u} (\tau)) = u_1(\tau)^2 +  u_2(\tau)^2 - U_\text{max}^2 \leq 0\\&amp; \mb{u}(\tau) \in \left[\mb{u}_{\min}, \mb{u}_{\max}\right]\end{aligned}\end{align} \]</div>
<p>is subject to the system dynamics given by <a class="reference internal" href="#equation-eq-tut-pmsm-model">(20)</a> and the
constraints given by <a class="reference internal" href="#equation-eq-tut-pmsm-stateconstr">(21)</a> and
<a class="reference internal" href="#equation-eq-tut-pmsm-inputconstr">(22)</a>.
The control constraints <a class="reference internal" href="#equation-eq-tut-pmsm-inputconstr">(22)</a> are
nonlinear and are therefore handled by the augmented Lagrangian
framework and not by the projection gradient method itself. It is
therefore reasonable to add the box constraints for <span class="math notranslate nohighlight">\(\mb{u}\)</span> with <span class="math notranslate nohighlight">\(\mb{u}_\text{min} = [-U_\text{max},-U_\text{max}]^\mathsf{T}\)</span> and
<span class="math notranslate nohighlight">\(\mb{u} _\text{max} = [U_\text{max},U_\text{max}]^\mathsf{T}\)</span> to the OCP formulation to enhance the overall robustness of the
algorithm. The cost functional consists of the integral part</p>
<div class="math notranslate nohighlight">
\[l(\mb{x}, \mb{u}) = q_1 (\mb{i}_\text{d} -  i_\text{d,des} )^2 + q_2 (\mb{i}_\text{q} -  i_\text{q,des} )^2 + (\mb{u} - \mb{u}_\text{des} ) ^\mathsf{T}\mb{R}  (\mb{u} - \mb{u}_\text{des} )\,,\]</div>
<p>with the setpoints for the states <span class="math notranslate nohighlight">\(i_\text{d,des}\)</span>,
<span class="math notranslate nohighlight">\(i_\text{q,des}\)</span> and controls
<span class="math notranslate nohighlight">\(\mb{u}_\mathrm{des} \in \mathbb{R}^2\)</span> respectively. The
weights are set to <span class="math notranslate nohighlight">\(q_1 = 8\,\mathrm{A^{-2}}\)</span>,
<span class="math notranslate nohighlight">\(q_2=200\,\mathrm{A^{-2}}\)</span> and <span class="math notranslate nohighlight">\(\mb{R} ={\rm diag}(0.001\,\mathrm{V^{-2}},0.001\,\mathrm{V^{-2}})\)</span>. The example considers a
startup of the motor from standstill by defining the setpoints
<span class="math notranslate nohighlight">\(i_\text{d,des}=0\,\mathrm{A}\)</span> and
<span class="math notranslate nohighlight">\(i_\text{q,des}=10\,\mathrm{A}\)</span>, corresponding to a constant
torque demand of <span class="math notranslate nohighlight">\(7.65\,\mathrm{N\,m}\)</span>. The desired controls are set to
<span class="math notranslate nohighlight">\(\mb{u}_\text{d,des}=[0\,\mathrm{V}, 0\,\mathrm{V}]^\mathsf{T}\)</span>.</p>
<p>The resulting OCP is solved by GRAMPC with the sampling time
<span class="math notranslate nohighlight">\(\Delta t = 125\,\mathrm{\mu s}\)</span> (parameter <code class="docutils literal notranslate"><span class="pre">dt</span></code>) and the horizon
<span class="math notranslate nohighlight">\(T = 5\,\mathrm{ms}\)</span> (parameter <code class="docutils literal notranslate"><span class="pre">Thor</span></code>) using standard options
almost exclusively. Only the number of discretization points <code class="docutils literal notranslate"><span class="pre">Nhor=11</span></code> , the
number of gradient iterations <code class="docutils literal notranslate"><span class="pre">MaxGradIter=3</span></code>  and the number of augmented
Lagrangian iterations <code class="docutils literal notranslate"><span class="pre">MaxMultIter=3</span></code>  are adapted to the problem. In addition, the
constraints tolerances <code class="docutils literal notranslate"><span class="pre">ConstraintsAbsTol</span></code> are set to 0.1% of the respective limit, i.e.
<span class="math notranslate nohighlight">\(0.1\,\mathrm{A^2}\)</span> and <span class="math notranslate nohighlight">\(104.5\,\mathrm{V^2}\)</span>. <code class="docutils literal notranslate"><span class="pre">PenaltyMin</span></code> is set to 2.5 x 10<sup>-7</sup> by
the estimation method of GRAMPC, see <a class="reference internal" href="algorithm.html#sec-algopt-estimpenmin"><span class="std std-ref">Estimation of minimal penalty parameter</span></a>.</p>
<p><a class="reference internal" href="#fig-pmsm-constr-unscaled"><span class="std std-numref">Fig. 7</span></a> illustrates the simulation
results. The setpoints are reached very fast and are stabilized almost
exactly. However, an overshoot can be observed, which also leads to a
small violation of the dq-current constraint by <span class="math notranslate nohighlight">\(0.45\,\mathrm{A}\)</span>. With increasing
rotor speed, the voltage also increases until the voltage constraint
becomes active. While the voltage constraint is almost exactly hold, the
dq-current constraint is clearly violated. The figure shows that at the
end of the simulation the dq-current constraint violation is more than
<span class="math notranslate nohighlight">\(1\,\mathrm{A}\)</span> or 10%. Though a larger number of iterations might be used to reduce
the constraint violation, the main reason for this deviation is that the
nonlinear voltage and current constraints differ in several orders of
magnitude. The next section therefore shows how to scale the problem in
GRAMPC.</p>
<p>Also note that the increase of the cost functional does not indicate
instability, but can be explained by the increasing speed, which affects
the control term in the cost with the control setpoints
<span class="math notranslate nohighlight">\((\mb{u}_\text{d,des}=[0\,\mathrm{V}, 0\,\mathrm{V}]^\mathsf{T})\)</span>.
Moreover, the current setpoints
<span class="math notranslate nohighlight">\((i_\text{d,des}=0\,\mathrm{A},\,i_\text{q,des}=10\,\mathrm{A})\)</span>
cannot be hold due to the
constraints <a class="reference internal" href="#equation-eq-tut-pmsm-stateconstr">(21)</a> and
<a class="reference internal" href="#equation-eq-tut-pmsm-inputconstr">(22)</a>, which leads to
an additional cost increase.</p>
</section>
<section id="constraints-scaling">
<h3>Constraints scaling<a class="headerlink" href="#constraints-scaling" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="fig-pmsm-constr-scaled">
<img alt="img/tikz/ext/ext_PMSM_constr_scaled.*" src="img/tikz/ext/ext_PMSM_constr_scaled.*" />
<figcaption>
<p><span class="caption-number">Fig. 8 </span><span class="caption-text">Simulated MPC trajectories for the PMSM example with scaled constraints.</span><a class="headerlink" href="#fig-pmsm-constr-scaled" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The two spherical constraints <a class="reference internal" href="#equation-eq-tut-pmsm-stateconstr">(21)</a> and
<a class="reference internal" href="#equation-eq-tut-pmsm-inputconstr">(22)</a> lie in very
different orders of magnitude, i.e. <span class="math notranslate nohighlight">\(I_\text{max}^2 =100\,\mathrm{A^2}\)</span>
and <span class="math notranslate nohighlight">\(U_\text{max}^2 =104329\,\mathrm{V^2}\)</span>.
Consequently, the two constraints should be scaled by the maximum value</p>
<div class="math notranslate nohighlight">
\[\frac{i_\text{d}^2+i_\text{q}^2}{I_\text{max}^2}-1 \leq 0\,,\qquad  \frac{u_\text{d}^2+u_\text{q}^2}{U_\text{max}^2}-1 \leq 0\,.\]</div>
<p>This scaling can either be done by hand directly in the problem function
or by activating the option <code class="docutils literal notranslate"><span class="pre">ScaleProblem</span></code> and setting <code class="docutils literal notranslate"><span class="pre">cScale</span></code> <span class="math notranslate nohighlight">\(=[I_\text{max}^2, U_\text{max}^2]\)</span>.
The scaling option of GRAMPC, however, causes
additional computing effort (approx. 45% for the PMSM problem). Hence,
this option is suitable for testing the scaling, but eventually should
be done manually in the problem formulation to achieve the highest
computational efficiency. In accordance with the scaling of the
constraints, the tolerances are also adapted to 1 x 10<sup>-3</sup>
corresponding to 0.1% of the scaled constraints limits.</p>
<p>Besides the scaling and <code class="docutils literal notranslate"><span class="pre">PenaltyMin</span></code> that is set to 2 x 10<sup>3</sup> by the
estimation routine of GRAMPC, all parameters and options are the same
as in the last subsection. Please note that the estimation method for <code class="docutils literal notranslate"><span class="pre">PenaltyMin</span></code>
strongly depends on reasonable constraint tolerances. In general, the
method returns rather conservative values, which may lead to constraint
violations if the order of magnitude of the constraints is very
different.</p>
<p><a class="reference internal" href="#fig-pmsm-constr-scaled"><span class="std std-numref">Fig. 8</span></a> shows a clear improvement in
terms of the dq-current constraint that is now fully exploited. The only
violation results from the overshoot at the beginning, which is in the
same range as in the unscaled case (approx. 0.35 A). Further
improvements, e.g. reduction of the overshoot, can be achieved by
optimizing the penalty update as described in the next subsection.</p>
</section>
<section id="optimization-of-the-penalty-update">
<h3>Optimization of the penalty update<a class="headerlink" href="#optimization-of-the-penalty-update" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="fig-pmsm-penalty-opt">
<img alt="img/tikz/ext/ext_PMSM_penalty_opt.*" src="img/tikz/ext/ext_PMSM_penalty_opt.*" />
<figcaption>
<p><span class="caption-number">Fig. 9 </span><span class="caption-text">Simulated MPC trajectories for the PMSM example with scaled constraints and optimized penalty update.</span><a class="headerlink" href="#fig-pmsm-penalty-opt" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In order to improve compliance with the dq-current constraint at the
beginning of the simulation, the number of augmented Lagrangian updates
is increased. To this end <code class="docutils literal notranslate"><span class="pre">AugLagUpdateGradientRelTol</span></code> is raised to 1, which means that in every
outer iteration an update of the multipliers and penalties is performed,
even if the inner minimization is not converged. Furthermore <code class="docutils literal notranslate"><span class="pre">PenaltyMin</span></code> , is raised
to 1 x 10<sup>4</sup> compared to the estimated value of 2 x 10<sup>3</sup>.
In addition, the plot of the step size, see the plot functions described
in <a class="reference internal" href="usage.html#sec-plotfunctions"><span class="std std-ref">Plot functions</span></a>, shows that the maximum value
<span class="math notranslate nohighlight">\(\alpha_\text{max}\)</span> is often used. Consequently, setting the
maximum step size <code class="docutils literal notranslate"><span class="pre">LineSearchMax</span></code> to 10 allows larger optimization steps, especially at
the beginning and at the end of the simulation. All other parameters and
options, in particular the scaling options, are the same as in the
previous subsection.</p>
<p><a class="reference internal" href="#fig-pmsm-penalty-opt"><span class="std std-numref">Fig. 9</span></a> illustrates the simulation result
with the optimized penalty update. The initial dq-current overshoot is
further reduced and the constraint is only violated by less than 0.07 A.
Furthermore, no oscillations occur in the costs and the augmented and
original cost are almost the same, which indicates that GRAMPC is well
tuned.</p>
<p>The computation time on a Windows 10 machine with Intel(R) Core(TM)
i5-5300U CPU running at 2.3 GHz using the Microsoft Visual C++ 2013
Professional (C) compiler amounts to 0.032 ms. On the dSpace real-time
hardware DS1202, the computation time is 0.13 ms.</p>
</section>
</section>
<section id="optimal-control-of-a-double-integrator">
<h2>Optimal control of a double integrator<a class="headerlink" href="#optimal-control-of-a-double-integrator" title="Link to this heading">¶</a></h2>
<figure class="align-default" id="fig-doubleint">
<img alt="img/tikz/ext/ext_DoubleInt.*" src="img/tikz/ext/ext_DoubleInt.*" />
<figcaption>
<p><span class="caption-number">Fig. 10 </span><span class="caption-text">Numerical OCP solution of the double integrator problem with fixed end time.</span><a class="headerlink" href="#fig-doubleint" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>This section describes how GRAMPC can be used to solve OCPs by
considering the example of a double integrator problem. The problem
formulation includes equality and inequality constraints. Both the
control variable <span class="math notranslate nohighlight">\(u\)</span> and the end time <span class="math notranslate nohighlight">\(T\)</span> serve as
optimization variables. In addition to the problem formulation of the
OCP, one focus of the following discussion will be the appropriate
convergence check of the augmented Lagrangian and gradient method, and
the optimization of the end time.</p>
<section id="problem-formulation-1">
<span id="id2"></span><h3>Problem formulation<a class="headerlink" href="#problem-formulation-1" title="Link to this heading">¶</a></h3>
<p>The double integrator problems reads as</p>
<div class="math notranslate nohighlight" id="equation-eq-ocp-doubleint">
<span class="eqno">(23)<a class="headerlink" href="#equation-eq-ocp-doubleint" title="Link to this equation">¶</a></span>\[\begin{split}\min_{u, T} \quad &amp; J(u, T;\mb{x}_0) = T + \int_0^T q_1u^2(t) \, {\rm d}t \\
\textrm{s.t.} \quad &amp; {\dot x_1}(t) = x_2(t) \,, \quad x_1(0) = x_{1,0} \\
&amp; {\dot x_2}(t) = u(t) \,, \quad x_2(0) = x_{2,0} \\
&amp; \mb{g}_{T}(\mb{x}(T))  = [x_1(T)\,, x_2(T)]^\mathsf{T}= \mb{0} \\
&amp; h(\mb{x} (t)) = x_2(t) - 0.5 \leq 0 \\
&amp; u(t) \in \left[u_{\min}, u_{\max}\right] \,,\quad T \in \left[T_{\min}, T_{\max}\right]\end{split}\]</div>
<p>including two terminal equality constraints <span class="math notranslate nohighlight">\(\mb{g}_{T}(\mb{x}(T))\)</span>
and one general inequality constraint <span class="math notranslate nohighlight">\(h(\mb{x} (t))\)</span>.
The control task consists in a setpoint transition from the initial
state <span class="math notranslate nohighlight">\(x_{1,0}=x_{2,0}=-1\)</span> to the origin <span class="math notranslate nohighlight">\(x_1(T)=x_2(T)=0\)</span>.
The cost functional <span class="math notranslate nohighlight">\(J(u, T;\mb{x}_0)\)</span> represents a
trade-off between time and energy optimality depending on the weight <span class="math notranslate nohighlight">\(q_1=0.1\)</span>.</p>
<p>The problem is formulated in GRAMPC using the C file
<code class="docutils literal notranslate"><span class="pre">probfct_DOUBLE_INTEGRATOR</span></code>, which can be found in <code class="docutils literal notranslate"><span class="pre">&lt;grampc_root&gt;/examples/Double_Integrator</span></code>. In particular,
the terminal equality constraints are formulated in GRAMPC via the functions <code class="docutils literal notranslate"><span class="pre">gTfct</span></code> , <code class="docutils literal notranslate"><span class="pre">dgTdx_vec</span></code> and <code class="docutils literal notranslate"><span class="pre">dgTdT_vec</span></code>.
The number of terminal equality constraints is set to <code class="docutils literal notranslate"><span class="pre">NgT</span></code> =2 in the function <code class="docutils literal notranslate"><span class="pre">ocp_dim</span></code>. Similarly,
the inequality constraint is formulated by means of the functions <code class="docutils literal notranslate"><span class="pre">hfct</span></code> , <code class="docutils literal notranslate"><span class="pre">dhdx_vec</span></code> and <code class="docutils literal notranslate"><span class="pre">dhdu_vec</span></code> and setting to <code class="docutils literal notranslate"><span class="pre">Nh</span></code> =1 in <code class="docutils literal notranslate"><span class="pre">ocp_dim</span></code>.
More details on implementing the OCP can be found in
<a class="reference internal" href="problem_formulation.html#sec-problemimplementation"><span class="std std-ref">Problem implementation</span></a> and in the example provided in the folder <code class="docutils literal notranslate"><span class="pre">&lt;grampc</span> <span class="pre">root&gt;/examples/Double</span> <span class="pre">Integrator</span></code>.</p>
<p>The options <code class="docutils literal notranslate"><span class="pre">OptimControl</span></code> and <code class="docutils literal notranslate"><span class="pre">OptimTime</span></code> are activated to optimize not only the control
variable <span class="math notranslate nohighlight">\(u\)</span> but also the end time <span class="math notranslate nohighlight">\(T\)</span>. The lower and upper
bounds of the optimzation variables are set to <span class="math notranslate nohighlight">\(u\in[-1,1]\)</span> and
<span class="math notranslate nohighlight">\(T\in[1,10]\)</span> using the parameters <code class="docutils literal notranslate"><span class="pre">umin</span></code> , <code class="docutils literal notranslate"><span class="pre">umax</span></code> , <code class="docutils literal notranslate"><span class="pre">Tmin</span></code> and <code class="docutils literal notranslate"><span class="pre">Tmax</span></code> ,
cf. <a class="reference internal" href="problem_formulation.html#chap-problemformulation"><span class="std std-ref">Problem formulation and implementation</span></a>. Note that the option <code class="docutils literal notranslate"><span class="pre">ShiftControl</span></code> is
deactivated, as the shifting of the control trajectory typically only
applies to MPC problems.</p>
<p>The option <code class="docutils literal notranslate"><span class="pre">ConvergenceCheck</span></code> is activated to terminate the augmented Lagrangian algorithm
as soon as the state constraints are fulfilled with sufficient accuracy
and the optimization variable has converged to an optimal value. To this
end, the convergence
criteria <a class="reference internal" href="algorithm.html#equation-eq-algopt-convgradient">(17)</a> and
<a class="reference internal" href="algorithm.html#equation-eq-algopt-convconstraints">(18)</a> are
evaluated after each gradient and augmented Lagrangian step using the
thresholds
<span class="math notranslate nohighlight">\(\mb{\varepsilon_{\mb{g}_T}}=[1e-6,1e-6]^\mathsf{T}\)</span>
and <span class="math notranslate nohighlight">\(\varepsilon_{\mb{h}}=1e-6\)</span>, cf. the option <code class="docutils literal notranslate"><span class="pre">ConstraintsAbsTol</span></code> .
The threshold for checking convergence of the optimization variable
<span class="math notranslate nohighlight">\(\varepsilon_\text{rel,c}\)</span> is set to <span class="math notranslate nohighlight">\(1e-9\)</span> via the
option <code class="docutils literal notranslate"><span class="pre">ConvergenceGradientRelTol</span></code> . Note that the activation of the convergence check using the
option <code class="docutils literal notranslate"><span class="pre">ConvergenceCheck</span></code> causes the gradient method to be aborted when the convergence
condition <span class="math notranslate nohighlight">\(\eta^{i|j+1} \leq \varepsilon_\text{rel,c}\)</span> defined by
<a class="reference internal" href="algorithm.html#equation-eq-algopt-convconstraints">(18)</a> is reached.</p>
</section>
<section id="optimization-with-fixed-end-time">
<h3>Optimization with fixed end time<a class="headerlink" href="#optimization-with-fixed-end-time" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="fig-doubleint-constr">
<img alt="img/tikz/ext/ext_DoubleInt_constr.*" src="img/tikz/ext/ext_DoubleInt_constr.*" />
<figcaption>
<p><span class="caption-number">Fig. 11 </span><span class="caption-text">Numerical OCP solution of the double integrator problem with fixed end time and state constraint.</span><a class="headerlink" href="#fig-doubleint-constr" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In a first scenario, the OCP <a class="reference internal" href="#equation-eq-ocp-doubleint">(23)</a> is numerically solved with the fixed end time <span class="math notranslate nohighlight">\(T=4\,\mathrm{s}\)</span>,
i.e., the option <code class="docutils literal notranslate"><span class="pre">OptimTime</span></code> is set <code class="docutils literal notranslate"><span class="pre">off</span></code> , and without the inequality
constraint, i.e., the option <code class="docutils literal notranslate"><span class="pre">InequalityConstraints</span></code> is also set <code class="docutils literal notranslate"><span class="pre">off</span></code> . The time interval <span class="math notranslate nohighlight">\([0,T]\)</span> is
discretized using <code class="docutils literal notranslate"><span class="pre">Nhor=50</span></code> discretization points. During the
augmented Lagrangian iterations, a decrease of the penalty parameters is
prevented by setting the adaptation factor <span class="math notranslate nohighlight">\(\beta_\text{de}=1\)</span>
(see option <code class="docutils literal notranslate"><span class="pre">PenaltyDecreaseFactor</span></code>). The increase factor <span class="math notranslate nohighlight">\(\beta_\text{in}\)</span> of the
penalty parameter update <a class="reference internal" href="algorithm.html#equation-eq-algopt-updatepenh">(14)</a> is set to the value
<span class="math notranslate nohighlight">\(1.25\)</span>. These settings ensure a fast convergence, since the
very low tolerances <span class="math notranslate nohighlight">\(\mb{\varepsilon_{\mb{g}_T}}\)</span>
require high penalty parameters. However, starting with high penalties
can lead to instabilities, as high penalties distort the optimization
problem.</p>
<p>As shown in <a class="reference internal" href="#fig-doubleint"><span class="std std-numref">Fig. 10</span></a>, the state variables
<span class="math notranslate nohighlight">\(\mb{x}(t)\)</span> are transferred to the origin as specified by
the terminal state constraints.
Note that only 5 augmented Lagrangian steps are required in total for
numerically solving the state constrained optimization problem in
accordance with the formulated convergence criterion for the terminal
equality constraints and the optimization variable <span class="math notranslate nohighlight">\(u\)</span>. The number
of gradient iterations varies in each augmented Lagrangian step as shown
in <a class="reference internal" href="#fig-doubleint"><span class="std std-numref">Fig. 10</span></a>. The violation of the formulated
terminal equality constraints continuously decreases below the specified thresholds
<span class="math notranslate nohighlight">\(\mb{\varepsilon_{\mb{g}_T}}=[1e-6,1e-6]^\mathsf{T}\)</span>.
As a result, the augmented cost functional and the original cost
functional converge to the same value, i.e. the so-called duality gap
is zero.</p>
<p>In a second scenario, <a class="reference internal" href="#fig-doubleint-constr"><span class="std std-numref">Fig. 11</span></a> shows the
optimal solution of OCP <a class="reference internal" href="#equation-eq-ocp-doubleint">(23)</a> with
activated inequality constraint using the fixed end time <span class="math notranslate nohighlight">\(T=5.25\,\mathrm{s}\)</span>. Further problem
settings are identical to the first simulation scenario. Again, the
terminal equality constraints are satisfied by the optimal solution and the state variables
<span class="math notranslate nohighlight">\(\mb{x}(t)\)</span> are transferred to the origin. The control
variable <span class="math notranslate nohighlight">\(u\)</span> is slightly adapted compared to the first simulation
scenario in <a class="reference internal" href="#fig-doubleint"><span class="std std-numref">Fig. 10</span></a> in order to comply with the inequality constraint.
In view of the additional inequality constraint, 17 augmented Lagrangian
steps are required to be able to solve the optimization problem with
sufficient accuracy.</p>
<p>The number of gradient iterations varies in each augmented Lagrangian
step as shown in <a class="reference internal" href="#fig-doubleint-constr"><span class="std std-numref">Fig. 11</span></a>. The
violation of the state constraints is almost continuously decreased
below the specified thresholds
<span class="math notranslate nohighlight">\(\mb{\varepsilon_{\mb{g}_T}}=[1e-6,1e-6]^\mathsf{T}\)</span>
and <span class="math notranslate nohighlight">\(\varepsilon_{\mb{h}}=1e-6\)</span>, respectively. As
before, the augmented cost functional and the original cost functional
converge to the same value. The computation time for solving the problem
on a Windows 10 machine with an Intel(R) Core(TM) i5-5300U CPU running
at 2.3GHz using the Microsoft Visual C++ 2013 Professional (C) compiler
amounts to 1.1ms and 14.6ms, respectively.</p>
</section>
<section id="optimization-with-free-end-time">
<h3>Optimization with free end time<a class="headerlink" href="#optimization-with-free-end-time" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="fig-doubleint-timeopt-constr">
<img alt="img/tikz/ext/ext_DoubleInt_Timeopt_constr.*" src="img/tikz/ext/ext_DoubleInt_Timeopt_constr.*" />
<figcaption>
<p><span class="caption-number">Fig. 12 </span><span class="caption-text">Numerical OCP solution of the double integrator problem with free end time and state constraint.</span><a class="headerlink" href="#fig-doubleint-timeopt-constr" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In a third simulation scenario, the
OCP <a class="reference internal" href="#equation-eq-ocp-doubleint">(23)</a> is numerically solved in
the free end time setting. The initial end time is set to
<span class="math notranslate nohighlight">\(T=5.25\,\mathrm{s}\)</span> as given before. To weight the update of
the end time <span class="math notranslate nohighlight">\(T\)</span> against the control update when updating the
optimization variables according to <a class="reference internal" href="algorithm.html#equation-eq-algopt-linesearchproblem">(6)</a>,
the adaptation factor <span class="math notranslate nohighlight">\(\gamma_{T}\)</span> is set using the option <code class="docutils literal notranslate"><span class="pre">OptimTimeLineSearchFactor</span></code>.
The value <span class="math notranslate nohighlight">\(\gamma_{T}=1.75\)</span> is used in the scenario. Note, however,
that values <span class="math notranslate nohighlight">\(\gamma_{T}&lt;1\)</span> typically increase the algorithmic
stability at the expense of the calculation time and vice versa.</p>
<p>The numerical results for the free end time case are shown in
<code class="xref math math-numref docutils literal notranslate"><span class="pre">fig:DoubleInt_Timeopt_constr</span></code>. In contrast to the first
two simulation scenarios, the reduction of the end time below
<span class="math notranslate nohighlight">\(4.6\,\mathrm{s}\)</span> allows one to carry out the setpoint
transition with a significantly more aggressive control
trajectory <span class="math notranslate nohighlight">\(u\)</span>. The free end time optimization is a more
challenging problem than before and is accompanied by a higher
computational effort. This can be observed both in the larger number of
augmented Lagrangian steps and gradient steps as well as in terms of the
slower improvement of the violation of the state constraints.</p>
<p>Nevertheless, the state constraints are fulfilled at the last augmented
Lagrangian step in accordance with the thresholds
<span class="math notranslate nohighlight">\(\mb{\varepsilon_{\mb{g}_T}}=[1e-6,1e-6]^\mathsf{T}\)</span>
and <span class="math notranslate nohighlight">\(\varepsilon_{\mb{h}}=1e-6\)</span>. The improvement of
the control performance when optimizing the end time compared to a fixed
end time can be specified by the lower value of the cost functional,
cf. <a class="reference internal" href="#fig-doubleint-constr"><span class="std std-numref">Fig. 11</span></a> and <a class="reference internal" href="#fig-doubleint-timeopt-constr"><span class="std std-numref">Fig. 12</span></a>.
However, this results in a slightly increased computation time of 21.96ms compared to 14.66ms
with a fixed end time on the same Windows 10 machine.</p>
</section>
</section>
<section id="moving-horizon-estimation-of-a-cstr">
<h2>Moving horizon estimation of a CSTR<a class="headerlink" href="#moving-horizon-estimation-of-a-cstr" title="Link to this heading">¶</a></h2>
<p>Continuous stirred tank reactors (CSTR) are a popular class of systems
when it comes to the implementation of advanced nonlinear control
methods. In this subsection, a CSTR model is used for an example
implementation of a moving horizon estimation (MHE) used in closed loop
with MPC. Corresponding m and C files can be found in the folder <code class="docutils literal notranslate"><span class="pre">&lt;grampc_root&gt;/examples/Reactor_CSTR</span></code>.</p>
<section id="problem-formulation-2">
<span id="id3"></span><h3>Problem formulation<a class="headerlink" href="#problem-formulation-2" title="Link to this heading">¶</a></h3>
<p>The system dynamic are given by <a class="footnote-reference brackets" href="#footcite-rothfuss1996" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a></p>
<div class="math notranslate nohighlight">
\[\begin{split}\dot c_\mathrm{A} &amp;= -k_1(T) c_\mathrm{A} - k_2(T) c_\mathrm{A}^2 + (c_{\mathrm{in}} - c_\mathrm{A}) u_1 \\
\dot c_\mathrm{B} &amp;= k_1(T) c_\mathrm{A} - k_1(T) c_\mathrm{B} - c_\mathrm{B} u_1 \\
\dot{T}~ &amp;= -\delta ( k_1(T) c_\mathrm{A} \Delta H_\mathrm{AB} + k_1(T) \Delta H_\mathrm{BC} + k_2(T) c_\mathrm{A}^2 \Delta H_\mathrm{AD}) \nonumber\\
&amp;\hspace{1cm}+ \alpha (T_\mathrm{C} - T) + (T_\mathrm{in} - T) u_1 \\
\dot{T}_\mathrm{C} &amp;= \beta (T - T_\mathrm{C}) + \gamma u_2\,,\end{split}\]</div>
<p>where the monomer and product concentrations <span class="math notranslate nohighlight">\(c_\mathrm{A}\)</span> and
<span class="math notranslate nohighlight">\(c_\mathrm{B}\)</span>, respectively, as well as the reactor and cooling
temperature <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(T_\mathrm{C}\)</span> form the state vector
<span class="math notranslate nohighlight">\(\mb{x} =[c_\mathrm{A}, c_\mathrm{B}, T, T_\mathrm{C}]\)</span>. The two functions
<span class="math notranslate nohighlight">\(k_1(T)\)</span> and <span class="math notranslate nohighlight">\(k_2(T)\)</span> are of Arrhenius type</p>
<div class="math notranslate nohighlight">
\[k_i(T) = k_{i0}  \exp \left(\frac{-E_i}{T/\mathrm{^\circ C} + 273.15} \right) ,\quad i =  1,2\,.\]</div>
<p>The measured quantities are the two temperatures
<span class="math notranslate nohighlight">\(\mb{y}=[T,T_C]^\mathsf{T}\)</span>. The controls
<span class="math notranslate nohighlight">\(\mb{u} = [u_1, u_2]\)</span>, i.e. the normalized flow rate and
the cooling power, are assumed to be known as well.
<a class="reference internal" href="#tab-cstrparams"><span class="std std-numref">Table 1</span></a> gives the parameters of the system that
are passed to the GRAMPC problem functions via <code class="docutils literal notranslate"><span class="pre">userparam</span></code>. A more detailed
description can be found in <a class="footnote-reference brackets" href="#footcite-rothfuss1996" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</p>
<table class="docutils align-default" id="tab-cstrparams">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Parameters of the CSTR mode <a class="footnote-reference brackets" href="#footcite-rothfuss1996" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>.</span><a class="headerlink" href="#tab-cstrparams" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Unit</p></th>
<th class="head"><p>Parameter</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Unit</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\alpha\)</span></p></td>
<td><p>30.828</p></td>
<td><p>h <sup>-1</sup></p></td>
<td><p><span class="math notranslate nohighlight">\(k_{20}\)</span></p></td>
<td><p>9.043 x 10 <sup>6</sup></p></td>
<td><p>m <sup>3</sup> mol <sup>-1</sup> h <sup>-1</sup></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\beta\)</span></p></td>
<td><p>86.688</p></td>
<td><p>h <sup>-1</sup></p></td>
<td><p><span class="math notranslate nohighlight">\(E_{1}\)</span></p></td>
<td><p>9785.3</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\delta\)</span></p></td>
<td><p>3.522 x 10 <sup>-4</sup></p></td>
<td><p>K kJ <sup>-1</sup></p></td>
<td><p><span class="math notranslate nohighlight">\(E_{2}\)</span></p></td>
<td><p>8560.0</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(\gamma\)</span></p></td>
<td><p>0.1</p></td>
<td><p>kh <sup>-1</sup></p></td>
<td><p><span class="math notranslate nohighlight">\(\Delta H_{AB}\)</span></p></td>
<td><p>4.2</p></td>
<td><p>kJ mol <sup>-1</sup></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(T_{in}\)</span></p></td>
<td><p>104.9</p></td>
<td><p>°C</p></td>
<td><p><span class="math notranslate nohighlight">\(\Delta H_{BC}\)</span></p></td>
<td><p>-11.0</p></td>
<td><p>kJ mol <sup>-1</sup></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(c_{in}\)</span></p></td>
<td><p>5.1 x 10 <sup>3</sup></p></td>
<td><p>mol m <sup>-3</sup></p></td>
<td><p><span class="math notranslate nohighlight">\(\Delta H_{AD}\)</span></p></td>
<td><p>-41.85</p></td>
<td><p>kJ mol <sup>-1</sup></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(k_{10}\)</span></p></td>
<td><p>1.287 x 10 <sup>12</sup></p></td>
<td><p>h <sup>-1</sup></p></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The control task at hand is the setpoint change between the two
stationary points</p>
<div class="math notranslate nohighlight">
\[\mb{x}_\mathrm{des,1} = [1370\,\mathrm{\frac{kmol}{m^3}}, 950\,\mathrm{\frac{kmol}{m^3}}, 110.0\,\mathrm{^\circ C}, 108.6\,\mathrm{^\circ C}]^\mathsf{T},  \mb{u}_\mathrm{des,1} = [5.0\,\mathrm{h^{-1}}, -1190\,\mathrm{kJ\,h^{-1}}]^\mathsf{T}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\mb{x}_\mathrm{des,2} = [2020\,\mathrm{\frac{kmol}{m^3}}, 1070\,\mathrm{\frac{kmol}{m^3}}, 100.0\,\mathrm{^\circ C}, 97.1\,\mathrm{^\circ C}]^\mathsf{T},  \mb{u}_\mathrm{des,2} = [5.0\,\mathrm{h^{-1}}, -2540\,\mathrm{kJ\,h^{-1}}]^\mathsf{T}.\]</div>
<p>The cost functional is designed quadratically</p>
<div class="math notranslate nohighlight">
\[J(\mb{u}, \mb{x}_k) := \Delta \mb{x}(T)^\mathsf{T}\mb{P} \Delta \mb{x}(T) + \int_{0}^{T} \Delta \mb{x}(t)^\mathsf{T}\mb{Q} \Delta \mb{x}(t) \Delta \mb{u}(t)^\mathsf{T}\mb{R} \Delta \mb{u}(t)\]</div>
<p>in order to penalize the deviation of the state and control from the
desired setpoint
<span class="math notranslate nohighlight">\((\mb{x}_\mathrm{des,1},\mb{u}_\mathrm{des,1})\)</span>
with
<span class="math notranslate nohighlight">\(\Delta \mb{x} = \mb{x} - \mb{x}_\mathrm{des}\)</span>
and
<span class="math notranslate nohighlight">\(\Delta \mb{u} = \mb{u} - \mb{u}_\mathrm{des}\)</span>.
The weight matrices are chosen as</p>
<div class="math notranslate nohighlight">
\[\mb{P} = \text{diag}(0.2, 1.0, 0.5,0.2),\,\, \mb{R} = \text{diag}(0.5, 5.0\mathrm{e-3}),\,\, \mb{Q} = \text{diag}(0.2, 1.0, 0.5, 0.2).\]</div>
<p>The control task will be tackled by MPC using GRAMPC. In addition, an
MHE using GRAMPC is designed to estimate the current state
<span class="math notranslate nohighlight">\(\mb{\hat x}_k\)</span> w.r.t. the measured temperatures
<span class="math notranslate nohighlight">\(\mb{y}=[T,T_C]^\mathsf{T}\)</span>.</p>
<p>In analogy to the MPC formulation <a class="reference internal" href="problem_formulation.html#equation-ocp">(1)</a>,
moving horizon estimation is typically based on the online solution of a
dynamic optimization problem</p>
<div class="math notranslate nohighlight" id="equation-eq-mhe-1-orig">
<span class="eqno">(24)<a class="headerlink" href="#equation-eq-mhe-1-orig" title="Link to this equation">¶</a></span>\[ \begin{align}\begin{aligned}    \min_{\mb{\hat x}_k} \quad &amp; J(\mb{\hat x}_k; \mb{u}, \mb{y}) = \int_{t_k-T}^{t_k} \| \mb{\hat y}(t) - \mb{y}(t) \|^2 \, {\rm d}t\\    \,\textrm{s.t.} \quad &amp; \mb{M}\mb{\dot{\hat x}}(t) = \mb{f}(\mb{\hat x}(t), \mb{u}(t),t) \,,\quad \mb{\hat x}(t_k) = \mb{\hat x}_k\\&amp; \mb{\hat y}(t) = \mb{\sigma}(\mb{\hat x}(t))\end{aligned}\end{align} \]</div>
<p>that depends on the history of the measured outputs
<span class="math notranslate nohighlight">\(\mb{y}(t)\)</span> and controls <span class="math notranslate nohighlight">\(\mb{u}(t)\)</span> in the
past time window <span class="math notranslate nohighlight">\([t_k - T, t_k]\)</span>. The solution of <a class="reference internal" href="#equation-eq-mhe-1-orig">(24)</a> yields the estimate of the state
<span class="math notranslate nohighlight">\(\mb{\hat{x}}_k\)</span> such that the difference between the
measured output <span class="math notranslate nohighlight">\(\mb{y}(t)\)</span> and the estimated output
function <span class="math notranslate nohighlight">\(\mb{\hat y}(t) = \mb{\sigma}(\mb{\hat x}(t))\)</span> is minimal in the sense of
<a class="reference internal" href="#equation-eq-mhe-1-orig">(24)</a>. GRAMPC solves this MHE problem by
means of parameter optimization. To this end, the state at the beginning
of the optimization horizon is defined as optimization variable,
i.e. <span class="math notranslate nohighlight">\(\mb{p} = \mb{\hat{x}}(t_k - T)\)</span>.</p>
<p>Both MHE and MPC use a sampling rate of
<span class="math notranslate nohighlight">\(\Delta t = 1\,\mathrm{s}\)</span>. A prediction horizon of
<span class="math notranslate nohighlight">\(T = 20\,\mathrm{min}\)</span> with 40 discretization points is used for the
MPC, while a prediction horizon of <span class="math notranslate nohighlight">\(T = 10\,\mathrm{s}\)</span> with 10
discretization points is used for the MHE. The MPC implementation uses
three gradient iterations per sampling step,
i.e. <span class="math notranslate nohighlight">\((i_\text{max},j_\text{max})=(1,3)\)</span>, while the implementation
of the MHE uses only a single gradient iteration,
i.e. <span class="math notranslate nohighlight">\((i_\text{max},j_\text{max}) =(1,1)\)</span>. Note that because the
MHE and MPC problems are defined without state constraints, the outer
augmented Lagrangian loop causes no computational overhead, as GRAMPC
skips the multiplier and penalty update. As the implementation of the
MHE is not quite as straightforward as the MPC case, the next subsection
describes the implementation process in more detail.</p>
</section>
<section id="implementation-aspects">
<h3>Implementation aspects<a class="headerlink" href="#implementation-aspects" title="Link to this heading">¶</a></h3>
<p>The following lines describe the implementation of the MHE problem with
GRAMPC, the corresponding simulation results are shown in the next
subsection. In a first step, the MHE
problem <a class="reference internal" href="#equation-eq-mhe-1-orig">(24)</a> has to be transformed in a
more suitable representation that can be tackled with the parameter
optimization functionality of GRAMPC. To this end, a coordinate
transformation</p>
<div class="math notranslate nohighlight" id="equation-eq-coordtrafo">
<span class="eqno">(25)<a class="headerlink" href="#equation-eq-coordtrafo" title="Link to this equation">¶</a></span>\[\mb{\tilde x}(\tau) = \mb{\hat x}(t_k\!-\!T\!+\!\tau) - \mb{p} \,,\quad
\mb{\tilde u}(\tau) = \mb{u}(t_k\!-\!T\!+\!\tau) \,,\quad
\mb{\tilde y}(\tau) = \mb{y}(t_k\!-\!T\!+\!\tau)\]</div>
<p>is used together with the corresponding time transformation from
<span class="math notranslate nohighlight">\(t\in [t_k-T,t_k]^\mathsf{T}\)</span> to the new time coordinate
<span class="math notranslate nohighlight">\(\tau \in [0, T]\)</span>. In combination with the optimization variable
<span class="math notranslate nohighlight">\(\mb{p} = \mb{\hat{x}}(t_k - T)\)</span> and the
homogeneous initial state
<span class="math notranslate nohighlight">\(\mb{\tilde{x}}(0) = \mb{0}\)</span>, the optimization
problem can be cast into the form</p>
<div class="math notranslate nohighlight" id="equation-eq-mhe-orig">
<span class="eqno">(26)<a class="headerlink" href="#equation-eq-mhe-orig" title="Link to this equation">¶</a></span>\[ \begin{align}\begin{aligned}    \min_{\mb{p}} \quad &amp; J(\mb{p}; \mb{\tilde u}, \mb{\tilde y}) = \int_0^T \| \mb{\hat y}(\tau) - \mb{\tilde y}(\tau) \|^2 \, {\rm d}\tau\\    \textrm{s.t.} \quad &amp; \mb{\dot{\tilde x}}(\tau) = \mb{f}(\mb{\tilde x}(\tau) + \mb{p}, \mb{\tilde u}(\tau), t_k\!-\!T\!+\!\tau) \,,\quad \mb{\tilde x}(0) = \mb{0}\\&amp; \mb{\hat y}(\tau) = \mb{\sigma}(\mb{\tilde x}(\tau)+\mb{p})\,.\end{aligned}\end{align} \]</div>
<p>The implementation of this optimization problem still requires to access
the measurements <span class="math notranslate nohighlight">\(\mb{\tilde y}\)</span> in the integral cost
term. This is achieved by appending the measurements to <code class="docutils literal notranslate"><span class="pre">userparam</span></code> (see <code class="docutils literal notranslate"><span class="pre">startMHE.m</span></code> in <code class="docutils literal notranslate"><span class="pre">&lt;grampc_root&gt;/examples/Reactor_CSTR</span></code>)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">init</span> <span class="n">array</span> <span class="n">of</span> <span class="n">last</span> <span class="n">MHE</span><span class="o">-</span><span class="n">Nhor</span> <span class="n">measurements</span> <span class="n">of</span> <span class="n">the</span> <span class="n">two</span> <span class="n">temperatures</span>
<span class="n">xMeas_array</span> <span class="o">=</span> <span class="n">repmat</span><span class="p">(</span><span class="n">grampcMPC</span><span class="o">.</span><span class="n">param</span><span class="o">.</span><span class="n">x0</span><span class="p">(</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">grampcMHE</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">Nhor</span><span class="p">);</span>
<span class="n">grampcMHE</span><span class="o">.</span><span class="n">userparam</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">grampcMHE</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">Nhor</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">xMeas_array</span><span class="p">;</span>
</pre></div>
</div>
<p>The measurements are updated in each iteration of the MPC/MHE loop, e.g.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="nb">set</span> <span class="n">values</span> <span class="n">of</span> <span class="n">last</span> <span class="n">MHE</span><span class="o">-</span><span class="n">Nhor</span> <span class="n">measurements</span> <span class="n">of</span> <span class="n">the</span> <span class="n">two</span> <span class="n">temperatures</span>
<span class="n">xMeas_temp</span> <span class="o">=</span> <span class="n">xtemp</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">;</span> <span class="o">%</span> <span class="n">measurement</span> <span class="n">noise</span>
<span class="n">xMeas_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">xMeas_array</span><span class="p">(</span><span class="mi">3</span><span class="p">:</span><span class="n">end</span><span class="p">),</span> <span class="n">xMeas_temp</span><span class="p">];</span>
<span class="n">grampcMHE</span><span class="o">.</span><span class="n">userparam</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">grampcMHE</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">Nhor</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="n">xMeas_array</span><span class="p">;</span>
</pre></div>
</div>
<p>When the number of discretization points and the horizon length is
known, the measurements can easily be accessed in the problem
description file in the following way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typeRNum</span><span class="o">*</span> <span class="n">pSys</span> <span class="o">=</span> <span class="p">(</span><span class="n">typeRNum</span><span class="o">*</span><span class="p">)</span><span class="n">userparam</span><span class="p">;</span>
<span class="n">typeRNum</span><span class="o">*</span> <span class="n">pCost</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pSys</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
<span class="n">typeRNum</span><span class="o">*</span> <span class="n">pMeas</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pSys</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="n">typeInt</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="n">floor</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="mf">2.777777777777778e-04</span> <span class="o">+</span> <span class="mf">0.00001</span><span class="p">);</span>
<span class="n">typeRNum</span> <span class="n">meas1</span> <span class="o">=</span> <span class="n">pMeas</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">index</span><span class="p">];</span>
<span class="n">typeRNum</span> <span class="n">meas2</span> <span class="o">=</span> <span class="n">pMeas</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span><span class="p">];</span>
</pre></div>
</div>
<p>The pointer <code class="docutils literal notranslate"><span class="pre">pMeas</span></code> is set to the 20th element of the <code class="docutils literal notranslate"><span class="pre">userparam</span></code> vector, since the first 14
are the system parameters given in <a class="reference internal" href="#tab-cstrparams"><span class="std std-numref">Table 1</span></a> and
the next six elements are the weights of the cost function. Also note
that <span class="math notranslate nohighlight">\(2.778e-4\,\mathrm{h^{-1}} \approx \Delta t\)</span>. Since the order of
magnitude of the individual states and controls differs a lot, the
scaling option <code class="docutils literal notranslate"><span class="pre">ScaleProblem</span></code> with</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\mb{x}_{\mathrm{scale}}  &amp;= [500\,\mathrm{\frac{kmol}{m^3}}, 500\,\mathrm{\frac{kmol}{m^3}}, 50\,\mathrm{^\circ C}, 50\,\mathrm{^\circ C}]^\mathsf{T}&amp; \mb{x}_{\mathrm{offset}} &amp;= [500\,\mathrm{\frac{kmol}{m^3}}, 500\,\mathrm{\frac{kmol}{m^3}}, 50\,\mathrm{^\circ C}, 50\,\mathrm{^\circ C}]^\mathsf{T}\\\mb{p}_{\mathrm{scale}}  &amp;= [500\,\mathrm{\frac{kmol}{m^3}}, 500\,\mathrm{\frac{kmol}{m^3}}, 50\,\mathrm{^\circ C}, 50\,\mathrm{^\circ C}]^\mathsf{T}&amp; \mb{p}_{\mathrm{offset}} &amp;= [500\,\mathrm{\frac{kmol}{m^3}}, 500\,\mathrm{\frac{kmol}{m^3}}, 50\,\mathrm{^\circ C}, 50\,\mathrm{^\circ C}]^\mathsf{T}\\\mb{u}_{\mathrm{scale}}  &amp;= [16\,\mathrm{h^{-1}}, 4500\,\mathrm{kJ h^{-1}}]^\mathsf{T}&amp;      \mb{u}_{\mathrm{offset}} &amp;= [19\,\mathrm{h^{-1}}, -4500\,\mathrm{kJ h^{-1}}]^\mathsf{T}\end{aligned}\end{align} \]</div>
<p>is activated.</p>
</section>
<section id="evaluation">
<h3>Evaluation<a class="headerlink" href="#evaluation" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="fig-cstr-closedloop">
<img alt="img/tikz/ext/ext_CSTR_closedLoop.*" src="img/tikz/ext/ext_CSTR_closedLoop.*" />
<figcaption>
<p><span class="caption-number">Fig. 13 </span><span class="caption-text">Simulated MHE/MPC trajectories for the CSTR reactor example.</span><a class="headerlink" href="#fig-cstr-closedloop" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The moving horizon estimator is evaluated in conjunction with the MPC.
The state estimates are initialized with an initial disturbance
<span class="math notranslate nohighlight">\(\delta \mb{p} = [100\,\mathrm{\frac{kmol}{m^3}}\)</span>,
<span class="math notranslate nohighlight">\(100\,\mathrm{\frac{kmol}{m^3}}\)</span>,
<span class="math notranslate nohighlight">\(5\,\mathrm{^\circ C}\)</span>,
<span class="math notranslate nohighlight">\(7\,\mathrm{^\circ C}]^\mathsf{T}\)</span>. For a more realistic
setting, white Gaussian noise with zero mean and a standard deviation of
<span class="math notranslate nohighlight">\(4\,\mathrm{^\circ C}\)</span> is added to the measurements
<span class="math notranslate nohighlight">\(\mb{y}=[T,T_C]^\mathsf{T}\)</span>.</p>
<p><a class="reference internal" href="#fig-cstr-closedloop"><span class="std std-numref">Fig. 13</span></a> shows the simulation results from
the closed loop simulation of the MHE in conjunction with the MPC. The
estimates <span class="math notranslate nohighlight">\(\mb{\hat x}_k\)</span> quickly converge to the actual
states (ground truth), as e.g.can be seen in the upper right plot.
Furthermore, the cost of the MPC quickly converges to zero after each
setpoint change at <span class="math notranslate nohighlight">\(t=0\,\mathrm{h}\)</span> and
<span class="math notranslate nohighlight">\(t=1.5\,\mathrm{h}\)</span>, respectively, which shows the good
performance of the combined MPC/MHE problem.</p>
<p>The corresponding computation times of GRAMPC amount to
<span class="math notranslate nohighlight">\(58\,\mathrm{\mu s}\)</span> and <span class="math notranslate nohighlight">\(11\,\mathrm{\mu s}\)</span> per
MPC and MHE step, respectively, on a Windows 10 machine with Intel(R)
Core(TM) i5-5300U CPU running at 2.3GHz using the Microsoft Visual C++
2013 Professional (C) compiler.</p>
</section>
</section>
<section id="differential-algebraic-equations">
<h2>Differential algebraic equations<a class="headerlink" href="#differential-algebraic-equations" title="Link to this heading">¶</a></h2>
<p>This section first introduces the DAE-system, before implementation
aspects regarding the dedicated DAE-solver RODAS are considered.
Finally, the example is evaluated.</p>
<section id="problem-formulation-3">
<span id="id7"></span><h3>Problem formulation<a class="headerlink" href="#problem-formulation-3" title="Link to this heading">¶</a></h3>
<p>The problem at hand is a toy example to illustrate the functionality of
GRAMPC with regard to the solution of DAEs. It consists of two
differential integrator states and one algebraic state. In addition,
this algebraic state is subject to an equality constraint. The
corresponding MPC problem is given by</p>
<div class="math notranslate nohighlight" id="equation-eq-daeexample">
<span class="eqno">(27)<a class="headerlink" href="#equation-eq-daeexample" title="Link to this equation">¶</a></span>\[ \begin{align}\begin{aligned}    \min_{u} \quad &amp; J(\mb{x}, \mb{u}) = \int_0^T \frac{1}{2}\left( {\Delta} \mb{x} \mb{Q} {\Delta} \mb{x}^\mathsf{T}+ \mb{u} \mb{R} \mb{u}^\mathsf{T}\right)  \, {\rm d}t\\    \textrm{s.t.} \quad &amp; {\dot x_1}(t) = u_1(t) \,, \quad \quad x_1(0) = x_{1,0}\\&amp; {\dot x_2}(t) = u_2(t) \,, \quad \quad x_2(0) = x_{2,0}\\&amp; \hspace{6.5mm} 0 = x_1(t) + x_2(t) - x_3(t)\\&amp; g(\mb{x}(t)) = x_3(t) - 1 = 0\\&amp; \mb{u}(t) \in \left[\mb{u}_{\min}, \mb{u}_{\max}\right],\end{aligned}\end{align} \]</div>
<p>where
<span class="math notranslate nohighlight">\(\Delta \mb{x} = \mb{x} - \mb{x}_{\mathrm{des}}\)</span>
and the weight matrices are chosen as
<span class="math notranslate nohighlight">\(\mb{Q}  = \text{diag}(500,0,0)\)</span> and
<span class="math notranslate nohighlight">\(\mb{R} = \text{diag}(1,1)\)</span>, respectively. The target of
the MPC formulation is to steer the first differential state to the
desired value, while remaining on the manifold defined by
<span class="math notranslate nohighlight">\(x_1(t) + x_2(t) = 1\)</span>. Note that this equation results from
substituting the algebraic equation into the constraint <span class="math notranslate nohighlight">\(g(\mb{x}(t))\)</span> .
Even though it would be possible to do this substitution and solve the resulting problem, the
purpose of this example is to illustrate the solution of a DAE.</p>
<p>The DAE given in <a class="reference internal" href="#equation-eq-daeexample">(27)</a> can be rewritten
with a mass matrix <span class="math notranslate nohighlight">\(\mb{M}\)</span>, i.e.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\underbrace{\begin{pmatrix}
    1 &amp; 0 &amp; 0\\
    0 &amp; 1 &amp; 0\\
    0 &amp; 0 &amp; 0\\
    \end{pmatrix}}_{\mb{M}} \dot{\mb{x}} = \underbrace{\begin{pmatrix}
                                                                              u_1\\
                                                                              u_2\\
                                                                              x_1 + x_2 - x_3\\
                                                                              \end{pmatrix}}_{\mb{f}(\mb{x}, \mb{u})}.\end{split}\]</div>
<p>Clearly, the mass matrix is different from the identity matrix and
singular, i.e. the inverse does not exist and therefore the solver RODAS
is used to integrate the system dynamics as well as the corresponding
adjoint dynamics.</p>
</section>
<section id="implementation-aspects-1">
<span id="id8"></span><h3>Implementation aspects<a class="headerlink" href="#implementation-aspects-1" title="Link to this heading">¶</a></h3>
<p>To solve the MPC problem for a DAE, the integrator RODAS has to be used
and some additional options have to be set. Furthermore, some additional
functions have to be implemented in the <code class="docutils literal notranslate"><span class="pre">probfct</span></code>-file.</p>
<p>The options are described in <a class="reference internal" href="algorithm.html#sec-algopt-integrationrodas"><span class="std std-ref">Integration of semi-implicit ODEs and DAEs (RODAS)</span></a>. In the example at
hand, the right hand side of the system dynamics is not explicitly
dependent on the time <span class="math notranslate nohighlight">\(t\)</span> and therefore
<code class="docutils literal notranslate"><span class="pre">IFCN</span></code> is set to zero. The next option concerns
the calculation of <span class="math notranslate nohighlight">\(\frac{\partial f}{\partial t}\)</span> and
<span class="math notranslate nohighlight">\(\frac{\partial^2 H}{\partial x \partial t}\)</span>. It can either be set
to zero (i.e. <span class="math notranslate nohighlight">\(\text{IDFX}=0\)</span>) and finite differences
are utilized or set to one (i.e. <span class="math notranslate nohighlight">\(\text{IDFX}=1\)</span>) and
the analytical solutions implemented in the functions <code class="docutils literal notranslate"><span class="pre">dfdt</span></code> and <code class="docutils literal notranslate"><span class="pre">dHdxdt</span></code> are called.
The third option determines if the numerical (i.e. finite differences)
or the analytical solution (i.e. <code class="docutils literal notranslate"><span class="pre">dfdx</span></code> and <code class="docutils literal notranslate"><span class="pre">dfdxtrans</span></code>) is used to compute the Jacobians
<span class="math notranslate nohighlight">\(\frac{\partial f}{\partial x}\)</span> and
<span class="math notranslate nohighlight">\((\frac{\partial f}{\partial x})^\mathrm{T} = \frac{\partial^2 H}{\partial x \partial \lambda}\)</span>.
The next option (<code class="docutils literal notranslate"><span class="pre">IMAS</span></code>) determines if the the mass matrix is equal to the
identity matrix (i.e. <span class="math notranslate nohighlight">\(\text{IMAS}=0\)</span>) or if it is
specified by the functions <code class="docutils literal notranslate"><span class="pre">Mfct</span></code> and <code class="docutils literal notranslate"><span class="pre">Mtrans</span></code> (i.e. <span class="math notranslate nohighlight">\(\text{IMAS}=1\)</span>).
In the current example, the mass matrix is singular (not the identity
matrix) and therefore the option is set to one. The remaining options
regard the size of the Jacobian and the mass matrix. The number of
non-zero lower and upper diagonals of the Jacobian are given by <code class="docutils literal notranslate"><span class="pre">MLJAC</span></code> and <code class="docutils literal notranslate"><span class="pre">MUJAC</span></code> ,
respectively. In our case, we have a full matrix and therefore set both
options to the system dimension, i.e. <span class="math notranslate nohighlight">\(N_{\mb{x}}\)</span>. The
only non-zero entries of the mass matrix lie on the main diagonal. Thus,
the corresponding options (i.e. <code class="docutils literal notranslate"><span class="pre">MLMAS</span></code> and <code class="docutils literal notranslate"><span class="pre">MUMAS</span></code>) are set to zero. Note that one has
to be careful, if the Jacobian or mass matrix are sparse, since the
lower and upper diagonals are padded with zeros. This is shown for the
example matrix in <a class="reference internal" href="#fig-examplemassmatrix"><span class="std std-numref">Fig. 14</span></a> with the
corresponding code in the following Example.</p>
<div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-number">Listing 6 </span><span class="caption-text">Example (C-Code for the mass function illustrated in <a class="reference internal" href="#fig-examplemassmatrix"><span class="std std-numref">Fig. 14</span></a>)</span><a class="headerlink" href="#id13" title="Link to this code">¶</a></div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Mfct</span><span class="p">(</span><span class="n">typeRNum</span><span class="w"> </span><span class="o">*</span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">typeUSERPARAM</span><span class="w"> </span><span class="o">*</span><span class="n">userparam</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">            </span><span class="cm">/* row 1 */</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="cm">/* row 2 */</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="cm">/* row 3 */</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="cm">/* row 4 */</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="cm">/* row 5 */</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">out</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
</pre></div>
</div>
</div>
<figure class="align-default" id="fig-examplemassmatrix">
<img alt="img/tikz/ext/ext_MassMatrixExample.*" src="img/tikz/ext/ext_MassMatrixExample.*" />
<figcaption>
<p><span class="caption-number">Fig. 14 </span><span class="caption-text">Example mass matrix with the index i showing at which position in the output array (i.e. out[i]) the corresponding value has to be written, cf. the example above.</span><a class="headerlink" href="#fig-examplemassmatrix" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="evaluation-1">
<span id="id9"></span><h3>Evaluation<a class="headerlink" href="#evaluation-1" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="fig-exampledae">
<img alt="img/tikz/ext/ext_ExampleDAE.*" src="img/tikz/ext/ext_ExampleDAE.*" />
<figcaption>
<p><span class="caption-number">Fig. 15 </span><span class="caption-text">Simulated MPC trajectories for the DAE-example</span><a class="headerlink" href="#fig-exampledae" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-exampledae"><span class="std std-numref">Fig. 15</span></a> shows the simulated trajectories for
three set point changes. The setpoint of the first state <span class="math notranslate nohighlight">\(x_1\)</span>
changes from 1 to 0 at <span class="math notranslate nohighlight">\(0\,\mathrm{s}\)</span>, from 0 to 0.5 after
<span class="math notranslate nohighlight">\(1\,\mathrm{s}\)</span>, and finally from 0.5 to 1 after
<span class="math notranslate nohighlight">\(2\,\mathrm{s}\)</span>. Due to the algebraic state and the equality
constraint, the trajectory of the second state <span class="math notranslate nohighlight">\(x_2\)</span> has to be the
mirror image of <span class="math notranslate nohighlight">\(x_1\)</span> around 0.5, which can be observed in the
upper left plot. The corresponding controls in the upper right plot are
also mirrored. The constraint violation during the simulation is shown
in the lower left plot of <a class="reference internal" href="#fig-exampledae"><span class="std std-numref">Fig. 15</span></a>. The allowed
constraint violation was set to 1 x 10<sup>-4</sup>, which is
approximately met. Lastly, the lower right plot shows the original
costs and the augmented costs. Both of which quickly converge to zero after each set
point change (after 0, 1 and <span class="math notranslate nohighlight">\(2\,\mathrm{s}\)</span>, respectively).</p>
</section>
</section>
<section id="constraint-tuning">
<h2>Constraint Tuning<a class="headerlink" href="#constraint-tuning" title="Link to this heading">¶</a></h2>
<p>This section shows how the options of GRAMPC can be adjusted in such a
way that the performance in terms of computation time and optimality is
improved. To this end, a specific OCP problem is considered. However,
the approach can serve as template for different problems.</p>
<section id="problem-formulation-4">
<span id="id10"></span><h3>Problem formulation<a class="headerlink" href="#problem-formulation-4" title="Link to this heading">¶</a></h3>
<p>The system at hand is a double integrator with one inequality constraint
and a terminal equality constraint for each state
<a class="footnote-reference brackets" href="#footcite-brysonho-book-1969" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. The OCP problem is then defined as</p>
<div class="math notranslate nohighlight" id="equation-eq-brysonexample">
<span class="eqno">(28)<a class="headerlink" href="#equation-eq-brysonexample" title="Link to this equation">¶</a></span>\[ \begin{align}\begin{aligned}    \min_{u} \quad &amp; J(\mb{x}, u) = \int_0^T r u^2 \, {\rm d}t\\    \textrm{s.t.} \quad &amp; {\dot x_1}(t) = x_2(t) \,, \qquad x_1(0) = x_{1,0}\\&amp; {\dot x_2}(t) = u(t) \,, \phantom{_2} \qquad x_2(0) = x_{2,0}\\&amp; h(\mb{x}(t)) = x_1(t) - 0.1 \leq 0\\&amp; g_{\mathrm{T},1}(\mb{x}(T)) = x_1(T) = 0\\&amp; g_{\mathrm{T},2}(\mb{x}(T)) = x_2(T) + 1 = 0,\end{aligned}\end{align} \]</div>
<p>with the weight <span class="math notranslate nohighlight">\(r= 0.5\)</span> and the initial state
<span class="math notranslate nohighlight">\(\mb{x}(0) = [0, 1]^\mathsf{T}\)</span>. The target of the problem
is to steer the double integrator states to the terminal state
<span class="math notranslate nohighlight">\(\mb{x}(T) = [0, -1]^\mathsf{T}\)</span> without violating the
inequality constraint <span class="math notranslate nohighlight">\(h(\mb{x}(t))\)</span> .
The time in which the set point change should be executed is set to
<span class="math notranslate nohighlight">\(T=1\,\mathrm{s}\)</span>.</p>
</section>
<section id="tuning-approach">
<h3>Tuning approach<a class="headerlink" href="#tuning-approach" title="Link to this heading">¶</a></h3>
<figure class="align-default" id="fig-brysonintegrator1">
<img alt="img/tikz/ext/ext_BrysonIntegrator1.*" src="img/tikz/ext/ext_BrysonIntegrator1.*" />
<figcaption>
<p><span class="caption-number">Fig. 16 </span><span class="caption-text">The prediction plot of GRAMPC for the double integrator example in <a class="reference internal" href="#equation-eq-brysonexample">(28)</a>.</span><a class="headerlink" href="#fig-brysonintegrator1" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>In the listing below, the step by step approach of tuning the parameters
of the augmented Lagrangian algorithm are detailed. The computation time
as well as the number of outer and inner iterations are shown in
<a class="reference internal" href="#tab-tuningcomptime"><span class="std std-numref">Table 2</span></a> along with the corresponding option
that was added or changed in each step.</p>
<table class="docutils align-default" id="tab-tuningcomptime">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">Computation time and outer / inner iteration count for the different settings. The last column shows which additional parameter was set different from the initial values in each step.</span><a class="headerlink" href="#tab-tuningcomptime" title="Link to this table">¶</a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Step</p></th>
<th class="head"><p>Time</p></th>
<th class="head"><p>MultIter</p></th>
<th class="head"><p>GradIter (mean)</p></th>
<th class="head"><p>Additional option</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ol class="arabic simple" start="0">
<li></li>
</ol>
</td>
<td><p>343 ms</p></td>
<td><p>3883</p></td>
<td><p>10.3</p></td>
<td><p>Default settings</p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple">
<li></li>
</ol>
</td>
<td><p>129 ms</p></td>
<td><p>637</p></td>
<td><p>22.4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">grampc_estim_penmin</span></code></p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="2">
<li></li>
</ol>
</td>
<td><p>59 ms</p></td>
<td><p>171</p></td>
<td><p>42.0</p></td>
<td><p><span class="math notranslate nohighlight">\(\text{PenaltyIncreaseFactor}=1.5\)</span></p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="3">
<li></li>
</ol>
</td>
<td><p>36 ms</p></td>
<td><p>98</p></td>
<td><p>46.6</p></td>
<td><p><span class="math notranslate nohighlight">\(\text{PenaltyIncreaseThreshold}=0.75\)</span></p></td>
</tr>
<tr class="row-even"><td><ol class="arabic simple" start="4">
<li></li>
</ol>
</td>
<td><p>22 ms</p></td>
<td><p>42</p></td>
<td><p>61.2</p></td>
<td><p><span class="math notranslate nohighlight">\(\text{LineSearchInit}=5\text{e-7}\)</span></p></td>
</tr>
<tr class="row-odd"><td><ol class="arabic simple" start="4">
<li></li>
</ol>
</td>
<td><p>22 ms</p></td>
<td><p>42</p></td>
<td><p>61.2</p></td>
<td><p><span class="math notranslate nohighlight">\(\text{PenaltyMin}=2\text{e4}\)</span></p></td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li><p>The choice of the initial penalty parameter is crucial for numerical
conditioning and therefore convergence. A value that is too high will
initially put an unnecessary amount of weight on constraint
satisfaction and mostly ignore the optimality. If the value is too
low, the opposite will happen, i.e. at first the cost function is
decreased at the cost of constraint violation. This will be
especially detrimental in MPC applications. If no prior knowledge is
available, it is recommended to use the function
<code class="docutils literal notranslate"><span class="pre">grampc_estim_penmin</span></code> (or the corresponding Cmex interface <code class="docutils literal notranslate"><span class="pre">grampc_estim_penmin_Cmex</span></code>).
For the example at hand, this reduces
the computation time by approximately a third.
<a class="reference internal" href="#fig-brysonintegrator1"><span class="std std-numref">Fig. 16</span></a> shows the simulation results
using the estimated value for <code class="docutils literal notranslate"><span class="pre">PenaltyMin</span></code>.</p></li>
<li><p>While the convergence speed is significantly increased, the penalty
parameters at <span class="math notranslate nohighlight">\(0.3\,\mathrm{s}\)</span> and <span class="math notranslate nohighlight">\(0.7\,\mathrm{s}\)</span>
are several magnitudes greater than the initial value. Since this
huge penalty parameter occurs only at two points during the
simulation, it is advisable to set the <code class="docutils literal notranslate"><span class="pre">PenaltyIncreaseFactor</span></code> to a bigger value. This again
reduces the computation time by more than half, since fewer increases
of the penalty parameter during the outer iterations are necessary.
The value should not be chosen too big, as this will have an adverse
effect on the numerical conditioning and convergence.</p></li>
<li><p>In accordance with the previous step, the threshold to increase the
penalty parameter, i.e. <code class="docutils literal notranslate"><span class="pre">PenaltyIncreaseThreshold</span></code> is lowered in order to increase the penalty
parameter more aggressively. This step almost doubles the convergence
speed. Note that this step and the previous step are interchangeable.</p></li>
<li><p>Another common tuning possibility is the initial step size of the
line search, especially if one of the explicit methods is used,
cf. <a class="reference internal" href="algorithm.html#sec-algopt-linesearchexplicit"><span class="std std-ref">Explicit line search</span></a>. Note that the
initial value <code class="docutils literal notranslate"><span class="pre">LineSearchInit</span></code> is used in the case that the explicit formula results
in a negative step size. One approach is to use the <code class="docutils literal notranslate"><span class="pre">LineSearchExpAutoFallback</span></code> option. However,
problem specific tuning (mostly trial and error) can result in a
significant performance boost. In the example at hand, this results
in approximately 40% faster convergence speed.</p></li>
<li><p>To further optimize the parameters, the estimation function for the
minimal penalty parameter can be deactivated again and a better value
for <code class="docutils literal notranslate"><span class="pre">PenaltyMin</span></code> be used (note that the parameter is increased until there is no
further improvement or an decrease in performance). This results in
an additional 15%` decrease of computation time.</p></li>
</ol>
<div class="docutils container" id="id12">
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="footcite-englert-cep-2018" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>T. Englert and K. Graichen. Nonlinear model predictive torque control of PMSMs for high performance applications. <em>Control Engineering Practice</em>, 81:43 – 54, 2018.</p>
</aside>
<aside class="footnote brackets" id="footcite-rothfuss1996" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id4">1</a>,<a role="doc-backlink" href="#id5">2</a>,<a role="doc-backlink" href="#id6">3</a>)</span>
<p>R. Rothfuss, J. Rudolph, and M. Zeitz. Flatness based control of a nonlinear chemical reactor model. <em>Automatica</em>, 32(10):1433–1439, 1996.</p>
</aside>
<aside class="footnote brackets" id="footcite-brysonho-book-1969" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">3</a><span class="fn-bracket">]</span></span>
<p>A. E. Bryson and Y.-C. Ho. <em>Applied Optimal Control</em>. Blaisdell, New York, USA, 1969.</p>
</aside>
</aside>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Tutorials</a><ul>
<li><a class="reference internal" href="#model-predictive-control-of-a-pmsm">Model predictive control of a PMSM</a><ul>
<li><a class="reference internal" href="#problem-formulation">Problem formulation</a></li>
<li><a class="reference internal" href="#constraints-scaling">Constraints scaling</a></li>
<li><a class="reference internal" href="#optimization-of-the-penalty-update">Optimization of the penalty update</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optimal-control-of-a-double-integrator">Optimal control of a double integrator</a><ul>
<li><a class="reference internal" href="#problem-formulation-1">Problem formulation</a></li>
<li><a class="reference internal" href="#optimization-with-fixed-end-time">Optimization with fixed end time</a></li>
<li><a class="reference internal" href="#optimization-with-free-end-time">Optimization with free end time</a></li>
</ul>
</li>
<li><a class="reference internal" href="#moving-horizon-estimation-of-a-cstr">Moving horizon estimation of a CSTR</a><ul>
<li><a class="reference internal" href="#problem-formulation-2">Problem formulation</a></li>
<li><a class="reference internal" href="#implementation-aspects">Implementation aspects</a></li>
<li><a class="reference internal" href="#evaluation">Evaluation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#differential-algebraic-equations">Differential algebraic equations</a><ul>
<li><a class="reference internal" href="#problem-formulation-3">Problem formulation</a></li>
<li><a class="reference internal" href="#implementation-aspects-1">Implementation aspects</a></li>
<li><a class="reference internal" href="#evaluation-1">Evaluation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constraint-tuning">Constraint Tuning</a><ul>
<li><a class="reference internal" href="#problem-formulation-4">Problem formulation</a></li>
<li><a class="reference internal" href="#tuning-approach">Tuning approach</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="usage.html"
                          title="previous chapter">Usage of GRAMPC</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="appendix.html"
                          title="next chapter">Appendix</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/tutorials.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="prf-prf.html" title="Proof Index"
             >Proof</a> |</li>
        <li class="right" >
          <a href="appendix.html" title="Appendix"
             >next</a> |</li>
        <li class="right" >
          <a href="usage.html" title="Usage of GRAMPC"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">grampc 2.3 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Tutorials</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Andreas Völz, Thore Wietzke.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.4.0.
    </div>
  </body>
</html>